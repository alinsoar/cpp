;; -*- mode:scheme ; buffer-read-only:t -*-

;; TREE RE -- this file was automatically generated by asdlgen

;;; regexp
 (define RE.POP
   (lambda (p:r)
     (define @TYPE 'regexp)
     (define @KONS 'RE.POP)
     (define POP
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((POP (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.POP)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.POP.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.POP.r (lambda (obj) (obj 'RE.POP.r)))
 (define RE.POP?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.POP))))

 (define RE.PUSH
   (lambda (p:r)
     (define @TYPE 'regexp)
     (define @KONS 'RE.PUSH)
     (define PUSH
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((PUSH (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.PUSH)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.PUSH.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.PUSH.r (lambda (obj) (obj 'RE.PUSH.r)))
 (define RE.PUSH?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.PUSH))))

 (define RE.EDGE
   (lambda (p:r p:p)
     (define @TYPE 'regexp)
     (define @KONS 'RE.EDGE)
     (define EDGE
       (lambda (self)
         (lambda (p:r p:p)
           (begin
             (tree-type-check self ROOT.symbol? p:r)
             (tree-type-check self ROOT.symbol? p:p))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r p:p)))))
     ((lambda (self) ((EDGE (self self)) p:r p:p))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.EDGE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.EDGE.r p:r)
            ('RE.EDGE.p p:p)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.EDGE.r (lambda (obj) (obj 'RE.EDGE.r)))
 (define RE.EDGE.p (lambda (obj) (obj 'RE.EDGE.p)))
 (define RE.EDGE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.EDGE))))

 (define RE.SET
   (lambda (p:r p:x)
     (define @TYPE 'regexp)
     (define @KONS 'RE.SET)
     (define SET
       (lambda (self)
         (lambda (p:r p:x)
           (begin
             (tree-type-check self ROOT.symbol? p:r)
             (tree-type-check self ROOT.bottom? p:x))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r p:x)))))
     ((lambda (self) ((SET (self self)) p:r p:x))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.SET)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.SET.r p:r)
            ('RE.SET.x p:x)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.SET.r (lambda (obj) (obj 'RE.SET.r)))
 (define RE.SET.x (lambda (obj) (obj 'RE.SET.x)))
 (define RE.SET?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.SET))))

 (define RE.ALTERNATIVE
   (lambda (p:r p:p)
     (define @TYPE 'regexp)
     (define @KONS 'RE.ALTERNATIVE)
     (define ALTERNATIVE
       (lambda (self)
         (lambda (p:r p:p)
           (begin
             (tree-type-check self ROOT.symbol? p:r)
             (tree-type-check self ROOT.symbol? p:p))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r p:p)))))
     ((lambda (self) ((ALTERNATIVE (self self)) p:r p:p))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.ALTERNATIVE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.ALTERNATIVE.r p:r)
            ('RE.ALTERNATIVE.p p:p)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.ALTERNATIVE.r (lambda (obj) (obj 'RE.ALTERNATIVE.r)))
 (define RE.ALTERNATIVE.p (lambda (obj) (obj 'RE.ALTERNATIVE.p)))
 (define RE.ALTERNATIVE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.ALTERNATIVE))))

 (define RE.KLEENE
   (lambda (p:r)
     (define @TYPE 'regexp)
     (define @KONS 'RE.KLEENE)
     (define KLEENE
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((KLEENE (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.KLEENE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.KLEENE.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.KLEENE.r (lambda (obj) (obj 'RE.KLEENE.r)))
 (define RE.KLEENE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.KLEENE))))

 (define RE.NEW
   (lambda (p:r)
     (define @TYPE 'regexp)
     (define @KONS 'RE.NEW)
     (define NEW
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.bottom? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((NEW (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.NEW)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.NEW.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.NEW.r (lambda (obj) (obj 'RE.NEW.r)))
 (define RE.NEW?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.NEW))))

 (define RE.regexp?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'regexp))))
;;; selectors for polymorphic attributes



;;; data
 (define RE.CH
   (lambda ()
     (define @TYPE 'data)
     (define @KONS 'RE.CH)
     (define CH (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((CH (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.CH)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.CH? (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.CH))))

 (define RE.UNION
   (lambda ()
     (define @TYPE 'data)
     (define @KONS 'RE.UNION)
     (define UNION (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((UNION (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.UNION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.UNION?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.UNION))))

 (define RE.INTERVAL
   (lambda ()
     (define @TYPE 'data)
     (define @KONS 'RE.INTERVAL)
     (define INTERVAL (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((INTERVAL (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.INTERVAL)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.INTERVAL?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.INTERVAL))))

 (define RE.data?
   (lambda (obj) (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'data))))
;;; selectors for polymorphic attributes


