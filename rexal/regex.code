;; -*- mode:scheme ; buffer-read-only:t -*-

;; TREE RE -- this file was automatically generated by asdlgen

;;; rexal
 (define RE.POP
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.POP)
     (define POP
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((POP (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.POP)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.POP.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.POP.r (lambda (obj) (obj 'RE.POP.r)))
 (define RE.POP?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.POP))))

 (define RE.PUSH
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.PUSH)
     (define PUSH
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((PUSH (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.PUSH)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.PUSH.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.PUSH.r (lambda (obj) (obj 'RE.PUSH.r)))
 (define RE.PUSH?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.PUSH))))

 (define RE.EDGE
   (lambda (p:r p:p)
     (define @TYPE 'rexal)
     (define @KONS 'RE.EDGE)
     (define EDGE
       (lambda (self)
         (lambda (p:r p:p)
           (begin
             (tree-type-check self ROOT.symbol? p:r)
             (tree-type-check self ROOT.symbol? p:p))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r p:p)))))
     ((lambda (self) ((EDGE (self self)) p:r p:p))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.EDGE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.EDGE.r p:r)
            ('RE.EDGE.p p:p)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.EDGE.r (lambda (obj) (obj 'RE.EDGE.r)))
 (define RE.EDGE.p (lambda (obj) (obj 'RE.EDGE.p)))
 (define RE.EDGE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.EDGE))))

 (define RE.ASSIGN
   (lambda (p:r p:x)
     (define @TYPE 'rexal)
     (define @KONS 'RE.ASSIGN)
     (define ASSIGN
       (lambda (self)
         (lambda (p:r p:x)
           (begin
             (tree-type-check self ROOT.symbol? p:r)
             (tree-type-check self ROOT.bottom? p:x))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r p:x)))))
     ((lambda (self) ((ASSIGN (self self)) p:r p:x))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.ASSIGN)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.ASSIGN.r p:r)
            ('RE.ASSIGN.x p:x)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.ASSIGN.r (lambda (obj) (obj 'RE.ASSIGN.r)))
 (define RE.ASSIGN.x (lambda (obj) (obj 'RE.ASSIGN.x)))
 (define RE.ASSIGN?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.ASSIGN))))

 (define RE.ALTERNATIVE
   (lambda (p:r p:p)
     (define @TYPE 'rexal)
     (define @KONS 'RE.ALTERNATIVE)
     (define ALTERNATIVE
       (lambda (self)
         (lambda (p:r p:p)
           (begin
             (tree-type-check self ROOT.symbol? p:r)
             (tree-type-check self ROOT.symbol? p:p))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r p:p)))))
     ((lambda (self) ((ALTERNATIVE (self self)) p:r p:p))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.ALTERNATIVE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.ALTERNATIVE.r p:r)
            ('RE.ALTERNATIVE.p p:p)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.ALTERNATIVE.r (lambda (obj) (obj 'RE.ALTERNATIVE.r)))
 (define RE.ALTERNATIVE.p (lambda (obj) (obj 'RE.ALTERNATIVE.p)))
 (define RE.ALTERNATIVE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.ALTERNATIVE))))

 (define RE.KLEENE
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.KLEENE)
     (define KLEENE
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((KLEENE (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.KLEENE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.KLEENE.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.KLEENE.r (lambda (obj) (obj 'RE.KLEENE.r)))
 (define RE.KLEENE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.KLEENE))))

 (define RE.NEW
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.NEW)
     (define NEW
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.bottom? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((NEW (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.NEW)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.NEW.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.NEW.r (lambda (obj) (obj 'RE.NEW.r)))
 (define RE.NEW?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.NEW))))

 (define RE.COMPLEMENT
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.COMPLEMENT)
     (define COMPLEMENT
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((COMPLEMENT (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.COMPLEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.COMPLEMENT.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.COMPLEMENT.r (lambda (obj) (obj 'RE.COMPLEMENT.r)))
 (define RE.COMPLEMENT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.COMPLEMENT))))

 (define RE.BOL
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.BOL)
     (define BOL
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((BOL (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.BOL)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.BOL.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.BOL.r (lambda (obj) (obj 'RE.BOL.r)))
 (define RE.BOL?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.BOL))))

 (define RE.DIFFERRENCE
   (lambda ()
     (define @TYPE 'rexal)
     (define @KONS 'RE.DIFFERRENCE)
     (define DIFFERRENCE (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((DIFFERRENCE (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.DIFFERRENCE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.DIFFERRENCE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.DIFFERRENCE))))

 (define RE.OPT
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.OPT)
     (define OPT
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((OPT (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.OPT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.OPT.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.OPT.r (lambda (obj) (obj 'RE.OPT.r)))
 (define RE.OPT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.OPT))))

 (define RE.ANY
   (lambda (p:r)
     (define @TYPE 'rexal)
     (define @KONS 'RE.ANY)
     (define ANY
       (lambda (self)
         (lambda (p:r) (begin (tree-type-check self ROOT.symbol? p:r)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r)))))
     ((lambda (self) ((ANY (self self)) p:r))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.ANY)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.ANY.r p:r)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.ANY.r (lambda (obj) (obj 'RE.ANY.r)))
 (define RE.ANY?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.ANY))))

 (define RE.INTERVAL
   (lambda (p:r p:p)
     (define @TYPE 'rexal)
     (define @KONS 'RE.INTERVAL)
     (define INTERVAL
       (lambda (self)
         (lambda (p:r p:p)
           (begin
             (tree-type-check self ROOT.symbol? p:r)
             (tree-type-check self ROOT.symbol? p:p))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:r p:p)))))
     ((lambda (self) ((INTERVAL (self self)) p:r p:p))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'RE.INTERVAL)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('RE.INTERVAL.r p:r)
            ('RE.INTERVAL.p p:p)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define RE.INTERVAL.r (lambda (obj) (obj 'RE.INTERVAL.r)))
 (define RE.INTERVAL.p (lambda (obj) (obj 'RE.INTERVAL.p)))
 (define RE.INTERVAL?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'RE.INTERVAL))))

 (define RE.rexal?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'rexal))))
;;; selectors for polymorphic attributes


