;; -*- mode:scheme ; buffer-read-only:t -*-

;; TREE PTREE -- this file was automatically generated by asdlgen

;;; storage_class_specifier
 (define PTREE.SCS
   (lambda (anon:0)
     (define @TYPE 'storage_class_specifier)
     (define @KONS 'PTREE.SCS)
     (define SCS
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check-list self CTOK.key? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((SCS (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.SCS)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.SCS?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.SCS))))

 (define PTREE.SCS_EMPTY
   (lambda ()
     (define @TYPE 'storage_class_specifier)
     (define @KONS 'PTREE.SCS_EMPTY)
     (define SCS_EMPTY (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((SCS_EMPTY (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.SCS_EMPTY)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.SCS_EMPTY?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.SCS_EMPTY))))

 (define PTREE.storage_class_specifier?
   (lambda (obj)
     (and (is/sum/type? obj)
          (procedure? obj)
          ((obj 'TYCK) 'storage_class_specifier))))
;;; selectors for polymorphic attributes



;;; type_specifier
 (define PTREE.TS
   (lambda (anon:0)
     (define @TYPE 'type_specifier)
     (define @KONS 'PTREE.TS)
     (define TS
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check-list self CTOK.key? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((TS (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.TS)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.TS?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.TS))))

 (define PTREE.TS_EMPTY
   (lambda ()
     (define @TYPE 'type_specifier)
     (define @KONS 'PTREE.TS_EMPTY)
     (define TS_EMPTY (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((TS_EMPTY (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.TS_EMPTY)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.TS_EMPTY?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.TS_EMPTY))))

 (define PTREE.type_specifier?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'type_specifier))))
;;; selectors for polymorphic attributes



;;; type_qualifier
 (define PTREE.TQ
   (lambda (anon:0)
     (define @TYPE 'type_qualifier)
     (define @KONS 'PTREE.TQ)
     (define TQ
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check-list self CTOK.key? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((TQ (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.TQ)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.TQ?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.TQ))))

 (define PTREE.TQ_EMPTY
   (lambda ()
     (define @TYPE 'type_qualifier)
     (define @KONS 'PTREE.TQ_EMPTY)
     (define TQ_EMPTY (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((TQ_EMPTY (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.TQ_EMPTY)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.TQ_EMPTY?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.TQ_EMPTY))))

 (define PTREE.type_qualifier?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'type_qualifier))))
;;; selectors for polymorphic attributes



;;; function_specifier
 (define PTREE.FS
   (lambda (anon:0)
     (define @TYPE 'function_specifier)
     (define @KONS 'PTREE.FS)
     (define FS
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check-list self CTOK.key? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((FS (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FS)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FS?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FS))))

 (define PTREE.FS_EMPTY
   (lambda ()
     (define @TYPE 'function_specifier)
     (define @KONS 'PTREE.FS_EMPTY)
     (define FS_EMPTY (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((FS_EMPTY (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FS_EMPTY)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FS_EMPTY?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FS_EMPTY))))

 (define PTREE.function_specifier?
   (lambda (obj)
     (and (is/sum/type? obj)
          (procedure? obj)
          ((obj 'TYCK) 'function_specifier))))
;;; selectors for polymorphic attributes



;;; type
 (define PTREE.TSPEC
   (lambda (anon:0 anon:1)
     (define @TYPE 'type)
     (define @KONS 'PTREE.TSPEC)
     (define TSPEC
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.type_specifier? anon:0)
             (tree-type-check self PTREE.type_qualifier? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((TSPEC (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.TSPEC)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.TSPEC?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.TSPEC))))

 (define PTREE.TNAME
   (lambda (anon:0 anon:1)
     (define @TYPE 'type)
     (define @KONS 'PTREE.TNAME)
     (define TNAME
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.type_specifier? anon:0)
             (tree-type-check self PTREE.type_qualifier? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((TNAME (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.TNAME)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.TNAME?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.TNAME))))

 (define PTREE.STRUCT
   (lambda (p:tag anon:1 anon:2)
     (define @TYPE 'type)
     (define @KONS 'PTREE.STRUCT)
     (define STRUCT
       (lambda (self)
         (lambda (p:tag anon:1 anon:2)
           (begin
             (tree-type-check self LEX.id? p:tag)
             (tree-type-check self PTREE.type_specifier? anon:1)
             (tree-type-check self PTREE.type_qualifier? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:tag anon:1 anon:2)))))
     ((lambda (self) ((STRUCT (self self)) p:tag anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.STRUCT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.STRUCT.tag p:tag)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.STRUCT.tag (lambda (obj) (obj 'PTREE.STRUCT.tag)))
 (define PTREE.STRUCT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.STRUCT))))

 (define PTREE.UNION
   (lambda (p:tag anon:1 anon:2)
     (define @TYPE 'type)
     (define @KONS 'PTREE.UNION)
     (define UNION
       (lambda (self)
         (lambda (p:tag anon:1 anon:2)
           (begin
             (tree-type-check self LEX.id? p:tag)
             (tree-type-check self PTREE.type_specifier? anon:1)
             (tree-type-check self PTREE.type_qualifier? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:tag anon:1 anon:2)))))
     ((lambda (self) ((UNION (self self)) p:tag anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.UNION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.UNION.tag p:tag)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.UNION.tag (lambda (obj) (obj 'PTREE.UNION.tag)))
 (define PTREE.UNION?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.UNION))))

 (define PTREE.ENUM
   (lambda (p:tag anon:1 anon:2)
     (define @TYPE 'type)
     (define @KONS 'PTREE.ENUM)
     (define ENUM
       (lambda (self)
         (lambda (p:tag anon:1 anon:2)
           (begin
             (tree-type-check self LEX.id? p:tag)
             (tree-type-check self PTREE.type_specifier? anon:1)
             (tree-type-check self PTREE.type_qualifier? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:tag anon:1 anon:2)))))
     ((lambda (self) ((ENUM (self self)) p:tag anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.ENUM)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.ENUM.tag p:tag)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.ENUM.tag (lambda (obj) (obj 'PTREE.ENUM.tag)))
 (define PTREE.ENUM?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.ENUM))))

 (define PTREE.POINTER
   (lambda (anon:0 anon:1)
     (define @TYPE 'type)
     (define @KONS 'PTREE.POINTER)
     (define POINTER
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.type? anon:0)
             (tree-type-check self PTREE.type_qualifier? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((POINTER (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.POINTER)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.POINTER?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.POINTER))))

 (define PTREE.FUNCTION_ANSI
   (lambda (anon:0 anon:1 anon:2 anon:3)
     (define @TYPE 'type)
     (define @KONS 'PTREE.FUNCTION_ANSI)
     (define FUNCTION_ANSI
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3)
           (begin
             (tree-type-check self PTREE.type? anon:0)
             (tree-type-check self ROOT.ct? anon:1)
             (tree-type-check-list self ROOT.bottom? anon:2)
             (tree-type-check self PTREE.type_qualifier? anon:3))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2 anon:3)))))
     ((lambda (self) ((FUNCTION_ANSI (self self)) anon:0 anon:1 anon:2 anon:3))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FUNCTION_ANSI)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FUNCTION_ANSI?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FUNCTION_ANSI))))

 (define PTREE.FUNCTION_KR
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'type)
     (define @KONS 'PTREE.FUNCTION_KR)
     (define FUNCTION_KR
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self PTREE.type? anon:0)
             (tree-type-check-list self LEX.id? anon:1)
             (tree-type-check self PTREE.type_qualifier? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((FUNCTION_KR (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FUNCTION_KR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FUNCTION_KR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FUNCTION_KR))))

 (define PTREE.ARRAY
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'type)
     (define @KONS 'PTREE.ARRAY)
     (define ARRAY
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self PTREE.type? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.type_qualifier? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((ARRAY (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.ARRAY)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.ARRAY?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.ARRAY))))

 (define PTREE.type?
   (lambda (obj) (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'type))))
;;; selectors for polymorphic attributes
 ()



;;; def
 (define PTREE.DEFVAR
   (lambda (anon:0 anon:1 anon:2 anon:3 anon:4)
     (define @TYPE 'def)
     (define @KONS 'PTREE.DEFVAR)
     (define DEFVAR
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3 anon:4)
           (begin
             (tree-type-check self PTREE.initializer? anon:0)
             (tree-type-check self LEX.id? anon:1)
             (tree-type-check self PTREE.type? anon:2)
             (tree-type-check self PTREE.storage_class_specifier? anon:3)
             (tree-type-check self PTREE.function_specifier? anon:4))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map tree-repr (list anon:0 anon:1 anon:2 anon:3 anon:4)))))
     ((lambda (self) ((DEFVAR (self self)) anon:0 anon:1 anon:2 anon:3 anon:4))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEFVAR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEFVAR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEFVAR))))

 (define PTREE.DEFTYPE
   (lambda (anon:0 anon:1 anon:2 anon:3 anon:4)
     (define @TYPE 'def)
     (define @KONS 'PTREE.DEFTYPE)
     (define DEFTYPE
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3 anon:4)
           (begin
             (tree-type-check self PTREE.initializer? anon:0)
             (tree-type-check self LEX.id? anon:1)
             (tree-type-check self PTREE.type? anon:2)
             (tree-type-check self PTREE.storage_class_specifier? anon:3)
             (tree-type-check self PTREE.function_specifier? anon:4))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map tree-repr (list anon:0 anon:1 anon:2 anon:3 anon:4)))))
     ((lambda (self) ((DEFTYPE (self self)) anon:0 anon:1 anon:2 anon:3 anon:4))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEFTYPE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEFTYPE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEFTYPE))))

 (define PTREE.TYPE
   (lambda (anon:0 anon:1 anon:2 anon:3)
     (define @TYPE 'def)
     (define @KONS 'PTREE.TYPE)
     (define TYPE
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3)
           (begin
             (tree-type-check self LEX.id? anon:0)
             (tree-type-check self PTREE.type? anon:1)
             (tree-type-check self PTREE.storage_class_specifier? anon:2)
             (tree-type-check self PTREE.function_specifier? anon:3))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2 anon:3)))))
     ((lambda (self) ((TYPE (self self)) anon:0 anon:1 anon:2 anon:3))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.TYPE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.TYPE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.TYPE))))

 (define PTREE.FUNPROTO_ANSI
   (lambda (anon:0 anon:1 anon:2 anon:3)
     (define @TYPE 'def)
     (define @KONS 'PTREE.FUNPROTO_ANSI)
     (define FUNPROTO_ANSI
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3)
           (begin
             (tree-type-check self LEX.id? anon:0)
             (tree-type-check self PTREE.type? anon:1)
             (tree-type-check self PTREE.storage_class_specifier? anon:2)
             (tree-type-check self PTREE.function_specifier? anon:3))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2 anon:3)))))
     ((lambda (self) ((FUNPROTO_ANSI (self self)) anon:0 anon:1 anon:2 anon:3))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FUNPROTO_ANSI)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FUNPROTO_ANSI?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FUNPROTO_ANSI))))

 (define PTREE.FUNDECL_KR
   (lambda (anon:0 anon:1 anon:2 anon:3)
     (define @TYPE 'def)
     (define @KONS 'PTREE.FUNDECL_KR)
     (define FUNDECL_KR
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3)
           (begin
             (tree-type-check self LEX.id? anon:0)
             (tree-type-check self PTREE.type? anon:1)
             (tree-type-check self PTREE.storage_class_specifier? anon:2)
             (tree-type-check self PTREE.function_specifier? anon:3))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2 anon:3)))))
     ((lambda (self) ((FUNDECL_KR (self self)) anon:0 anon:1 anon:2 anon:3))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FUNDECL_KR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FUNDECL_KR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FUNDECL_KR))))

 (define PTREE.PARAM
   (lambda (anon:0 anon:1 anon:2 anon:3)
     (define @TYPE 'def)
     (define @KONS 'PTREE.PARAM)
     (define PARAM
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3)
           (begin
             (tree-type-check self LEX.id? anon:0)
             (tree-type-check self PTREE.type? anon:1)
             (tree-type-check self PTREE.storage_class_specifier? anon:2)
             (tree-type-check self PTREE.function_specifier? anon:3))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2 anon:3)))))
     ((lambda (self) ((PARAM (self self)) anon:0 anon:1 anon:2 anon:3))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.PARAM)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.PARAM?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.PARAM))))

 (define PTREE.MEMBER
   (lambda (anon:0 anon:1 anon:2 anon:3)
     (define @TYPE 'def)
     (define @KONS 'PTREE.MEMBER)
     (define MEMBER
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3)
           (begin
             (tree-type-check self LEX.id? anon:0)
             (tree-type-check self PTREE.type? anon:1)
             (tree-type-check self PTREE.storage_class_specifier? anon:2)
             (tree-type-check self PTREE.function_specifier? anon:3))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2 anon:3)))))
     ((lambda (self) ((MEMBER (self self)) anon:0 anon:1 anon:2 anon:3))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.MEMBER)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.MEMBER?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.MEMBER))))

 (define PTREE.BITFIELD
   (lambda (anon:0 anon:1 anon:2 anon:3 anon:4)
     (define @TYPE 'def)
     (define @KONS 'PTREE.BITFIELD)
     (define BITFIELD
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3 anon:4)
           (begin
             (tree-type-check self PTREE.initializer? anon:0)
             (tree-type-check self LEX.id? anon:1)
             (tree-type-check self PTREE.type? anon:2)
             (tree-type-check self PTREE.storage_class_specifier? anon:3)
             (tree-type-check self PTREE.function_specifier? anon:4))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map tree-repr (list anon:0 anon:1 anon:2 anon:3 anon:4)))))
     ((lambda (self)
        ((BITFIELD (self self)) anon:0 anon:1 anon:2 anon:3 anon:4))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.BITFIELD)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.BITFIELD?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.BITFIELD))))

 (define PTREE.def?
   (lambda (obj) (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'def))))
;;; selectors for polymorphic attributes
 ()
 ()
 ()
 ()



;;; fundef
 (define PTREE.DEFUN
   (lambda (p:body anon:1)
     (define @TYPE 'fundef)
     (define @KONS 'PTREE.DEFUN)
     (define DEFUN
       (lambda (self)
         (lambda (p:body anon:1)
           (begin
             (tree-type-check self PTREE.statement? p:body)
             (tree-type-check self PTREE.def? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:body anon:1)))))
     ((lambda (self) ((DEFUN (self self)) p:body anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEFUN)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DEFUN.body p:body)
            ('PTREE.fundef.body ((s s) 'PTREE.DEFUN.body))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEFUN.body (lambda (obj) (obj 'PTREE.DEFUN.body)))
 (define PTREE.DEFUN?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEFUN))))

 (define PTREE.DEFUN_KR
   (lambda (anon:0 p:body anon:2)
     (define @TYPE 'fundef)
     (define @KONS 'PTREE.DEFUN_KR)
     (define DEFUN_KR
       (lambda (self)
         (lambda (anon:0 p:body anon:2)
           (begin
             (tree-type-check-list self PTREE.def? anon:0)
             (tree-type-check self PTREE.statement? p:body)
             (tree-type-check self PTREE.def? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 p:body anon:2)))))
     ((lambda (self) ((DEFUN_KR (self self)) anon:0 p:body anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEFUN_KR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DEFUN_KR.body p:body)
            ('PTREE.fundef.body ((s s) 'PTREE.DEFUN_KR.body))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEFUN_KR.body (lambda (obj) (obj 'PTREE.DEFUN_KR.body)))
 (define PTREE.DEFUN_KR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEFUN_KR))))

 (define PTREE.fundef?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'fundef))))
;;; selectors for polymorphic attributes
 (define PTREE.fundef.body
   (lambda (obj)
     (or (PTREE.fundef? obj) (error "poly-attribute" 'fundef 'body))
     (obj 'PTREE.fundef.body)))
 ()



;;; deftag
 (define PTREE.DEFTAG_STRUCT
   (lambda (anon:0 p:tag)
     (define @TYPE 'deftag)
     (define @KONS 'PTREE.DEFTAG_STRUCT)
     (define DEFTAG_STRUCT
       (lambda (self)
         (lambda (anon:0 p:tag)
           (begin
             (tree-type-check-list self PTREE.def? anon:0)
             (tree-type-check self LEX.id? p:tag))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 p:tag)))))
     ((lambda (self) ((DEFTAG_STRUCT (self self)) anon:0 p:tag))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEFTAG_STRUCT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DEFTAG_STRUCT.tag p:tag)
            ('PTREE.deftag.tag ((s s) 'PTREE.DEFTAG_STRUCT.tag))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEFTAG_STRUCT.tag (lambda (obj) (obj 'PTREE.DEFTAG_STRUCT.tag)))
 (define PTREE.DEFTAG_STRUCT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEFTAG_STRUCT))))

 (define PTREE.DEFTAG_UNION
   (lambda (anon:0 p:tag)
     (define @TYPE 'deftag)
     (define @KONS 'PTREE.DEFTAG_UNION)
     (define DEFTAG_UNION
       (lambda (self)
         (lambda (anon:0 p:tag)
           (begin
             (tree-type-check-list self PTREE.def? anon:0)
             (tree-type-check self LEX.id? p:tag))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 p:tag)))))
     ((lambda (self) ((DEFTAG_UNION (self self)) anon:0 p:tag))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEFTAG_UNION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DEFTAG_UNION.tag p:tag)
            ('PTREE.deftag.tag ((s s) 'PTREE.DEFTAG_UNION.tag))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEFTAG_UNION.tag (lambda (obj) (obj 'PTREE.DEFTAG_UNION.tag)))
 (define PTREE.DEFTAG_UNION?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEFTAG_UNION))))

 (define PTREE.DEFTAG_ENUM
   (lambda (anon:0 p:tag)
     (define @TYPE 'deftag)
     (define @KONS 'PTREE.DEFTAG_ENUM)
     (define DEFTAG_ENUM
       (lambda (self)
         (lambda (anon:0 p:tag)
           (begin
             (tree-type-check-list self PTREE.enumerator? anon:0)
             (tree-type-check self LEX.id? p:tag))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 p:tag)))))
     ((lambda (self) ((DEFTAG_ENUM (self self)) anon:0 p:tag))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEFTAG_ENUM)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DEFTAG_ENUM.tag p:tag)
            ('PTREE.deftag.tag ((s s) 'PTREE.DEFTAG_ENUM.tag))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEFTAG_ENUM.tag (lambda (obj) (obj 'PTREE.DEFTAG_ENUM.tag)))
 (define PTREE.DEFTAG_ENUM?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEFTAG_ENUM))))

 (define PTREE.DECLTAG_STRUCT
   (lambda (p:tag)
     (define @TYPE 'deftag)
     (define @KONS 'PTREE.DECLTAG_STRUCT)
     (define DECLTAG_STRUCT
       (lambda (self)
         (lambda (p:tag) (begin (tree-type-check self LEX.id? p:tag)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:tag)))))
     ((lambda (self) ((DECLTAG_STRUCT (self self)) p:tag))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DECLTAG_STRUCT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DECLTAG_STRUCT.tag p:tag)
            ('PTREE.deftag.tag ((s s) 'PTREE.DECLTAG_STRUCT.tag))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DECLTAG_STRUCT.tag
   (lambda (obj) (obj 'PTREE.DECLTAG_STRUCT.tag)))
 (define PTREE.DECLTAG_STRUCT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DECLTAG_STRUCT))))

 (define PTREE.DECLTAG_UNION
   (lambda (p:tag)
     (define @TYPE 'deftag)
     (define @KONS 'PTREE.DECLTAG_UNION)
     (define DECLTAG_UNION
       (lambda (self)
         (lambda (p:tag) (begin (tree-type-check self LEX.id? p:tag)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:tag)))))
     ((lambda (self) ((DECLTAG_UNION (self self)) p:tag))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DECLTAG_UNION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DECLTAG_UNION.tag p:tag)
            ('PTREE.deftag.tag ((s s) 'PTREE.DECLTAG_UNION.tag))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DECLTAG_UNION.tag (lambda (obj) (obj 'PTREE.DECLTAG_UNION.tag)))
 (define PTREE.DECLTAG_UNION?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DECLTAG_UNION))))

 (define PTREE.DECLTAG_ENUM
   (lambda (p:tag)
     (define @TYPE 'deftag)
     (define @KONS 'PTREE.DECLTAG_ENUM)
     (define DECLTAG_ENUM
       (lambda (self)
         (lambda (p:tag) (begin (tree-type-check self LEX.id? p:tag)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:tag)))))
     ((lambda (self) ((DECLTAG_ENUM (self self)) p:tag))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DECLTAG_ENUM)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PTREE.DECLTAG_ENUM.tag p:tag)
            ('PTREE.deftag.tag ((s s) 'PTREE.DECLTAG_ENUM.tag))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DECLTAG_ENUM.tag (lambda (obj) (obj 'PTREE.DECLTAG_ENUM.tag)))
 (define PTREE.DECLTAG_ENUM?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DECLTAG_ENUM))))

 (define PTREE.deftag?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'deftag))))
;;; selectors for polymorphic attributes
 (define PTREE.deftag.tag
   (lambda (obj)
     (or (PTREE.deftag? obj) (error "poly-attribute" 'deftag 'tag))
     (obj 'PTREE.deftag.tag)))



;;; def_static
 (define PTREE.DEF_STATIC_CONSTANT
   (lambda (anon:0 anon:1)
     (define @TYPE 'def_static)
     (define @KONS 'PTREE.DEF_STATIC_CONSTANT)
     (define DEF_STATIC_CONSTANT
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self LEX.tok_ct? anon:0)
             (tree-type-check self LEX.string? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((DEF_STATIC_CONSTANT (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DEF_STATIC_CONSTANT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DEF_STATIC_CONSTANT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DEF_STATIC_CONSTANT))))

 (define PTREE.def_static?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'def_static))))
;;; selectors for polymorphic attributes



;;; enumerator
 (define PTREE.ENUMERATOR
   (lambda (anon:0 anon:1)
     (define @TYPE 'enumerator)
     (define @KONS 'PTREE.ENUMERATOR)
     (define ENUMERATOR
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self LEX.id? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((ENUMERATOR (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.ENUMERATOR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.ENUMERATOR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.ENUMERATOR))))

 (define PTREE.ENUMERATOR_NOINIT
   (lambda (anon:0)
     (define @TYPE 'enumerator)
     (define @KONS 'PTREE.ENUMERATOR_NOINIT)
     (define ENUMERATOR_NOINIT
       (lambda (self)
         (lambda (anon:0) (begin (tree-type-check self LEX.id? anon:0)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((ENUMERATOR_NOINIT (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.ENUMERATOR_NOINIT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.ENUMERATOR_NOINIT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.ENUMERATOR_NOINIT))))

 (define PTREE.enumerator?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'enumerator))))
;;; selectors for polymorphic attributes



;;; expression
 (define PTREE.EMPTY_EXPRESSION
   (lambda ()
     (define @TYPE 'expression)
     (define @KONS 'PTREE.EMPTY_EXPRESSION)
     (define EMPTY_EXPRESSION (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((EMPTY_EXPRESSION (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.EMPTY_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.EMPTY_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.EMPTY_EXPRESSION))))

 (define PTREE.PRIMARY_CONSTANT_EXPRESSION
   (lambda (anon:0)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.PRIMARY_CONSTANT_EXPRESSION)
     (define PRIMARY_CONSTANT_EXPRESSION
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check self LEX.tok_ct? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((PRIMARY_CONSTANT_EXPRESSION (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.PRIMARY_CONSTANT_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.PRIMARY_CONSTANT_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.PRIMARY_CONSTANT_EXPRESSION))))

 (define PTREE.ARRAY_SUBSCRIPT_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.ARRAY_SUBSCRIPT_EXPRESSION)
     (define ARRAY_SUBSCRIPT_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((ARRAY_SUBSCRIPT_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.ARRAY_SUBSCRIPT_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.ARRAY_SUBSCRIPT_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.ARRAY_SUBSCRIPT_EXPRESSION))))

 (define PTREE.FUNCTION_CALL_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.FUNCTION_CALL_EXPRESSION)
     (define FUNCTION_CALL_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check-list self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((FUNCTION_CALL_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FUNCTION_CALL_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FUNCTION_CALL_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FUNCTION_CALL_EXPRESSION))))

 (define PTREE.STRUCT_UNION_DIRECT_MEMBER_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.STRUCT_UNION_DIRECT_MEMBER_EXPRESSION)
     (define STRUCT_UNION_DIRECT_MEMBER_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self LEX.id? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self)
        ((STRUCT_UNION_DIRECT_MEMBER_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.STRUCT_UNION_DIRECT_MEMBER_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.STRUCT_UNION_DIRECT_MEMBER_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.STRUCT_UNION_DIRECT_MEMBER_EXPRESSION))))

 (define PTREE.STRUCT_UNION_POINTER_MEMBER_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.STRUCT_UNION_POINTER_MEMBER_EXPRESSION)
     (define STRUCT_UNION_POINTER_MEMBER_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self LEX.id? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self)
        ((STRUCT_UNION_POINTER_MEMBER_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.STRUCT_UNION_POINTER_MEMBER_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.STRUCT_UNION_POINTER_MEMBER_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.STRUCT_UNION_POINTER_MEMBER_EXPRESSION))))

 (define PTREE.POST_INCREMENTER_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.POST_INCREMENTER_EXPRESSION)
     (define POST_INCREMENTER_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((POST_INCREMENTER_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.POST_INCREMENTER_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.POST_INCREMENTER_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.POST_INCREMENTER_EXPRESSION))))

 (define PTREE.POST_DECREMENTER_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.POST_DECREMENTER_EXPRESSION)
     (define POST_DECREMENTER_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((POST_DECREMENTER_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.POST_DECREMENTER_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.POST_DECREMENTER_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.POST_DECREMENTER_EXPRESSION))))

 (define PTREE.COMPOUND_LITERAL_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.COMPOUND_LITERAL_EXPRESSION)
     (define COMPOUND_LITERAL_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.def? anon:0)
             (tree-type-check-list self PTREE.design_init? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((COMPOUND_LITERAL_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.COMPOUND_LITERAL_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.COMPOUND_LITERAL_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.COMPOUND_LITERAL_EXPRESSION))))

 (define PTREE.UNARY_OPERATOR_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.UNARY_OPERATOR_EXPRESSION)
     (define UNARY_OPERATOR_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((UNARY_OPERATOR_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.UNARY_OPERATOR_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.UNARY_OPERATOR_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.UNARY_OPERATOR_EXPRESSION))))

 (define PTREE.UNARY_SIZEOF_EXPR_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.UNARY_SIZEOF_EXPR_EXPRESSION)
     (define UNARY_SIZEOF_EXPR_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self CTOK.key? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((UNARY_SIZEOF_EXPR_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.UNARY_SIZEOF_EXPR_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.UNARY_SIZEOF_EXPR_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.UNARY_SIZEOF_EXPR_EXPRESSION))))

 (define PTREE.PRE_UNARY_INCREMENTER_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.PRE_UNARY_INCREMENTER_EXPRESSION)
     (define PRE_UNARY_INCREMENTER_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self CTOK.key? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self)
        ((PRE_UNARY_INCREMENTER_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.PRE_UNARY_INCREMENTER_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.PRE_UNARY_INCREMENTER_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.PRE_UNARY_INCREMENTER_EXPRESSION))))

 (define PTREE.PRE_UNARY_DECREMENTER_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.PRE_UNARY_DECREMENTER_EXPRESSION)
     (define PRE_UNARY_DECREMENTER_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self CTOK.key? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self)
        ((PRE_UNARY_DECREMENTER_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.PRE_UNARY_DECREMENTER_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.PRE_UNARY_DECREMENTER_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.PRE_UNARY_DECREMENTER_EXPRESSION))))

 (define PTREE.CAST_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.CAST_EXPRESSION)
     (define CAST_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.def? anon:0)
             (tree-type-check self PTREE.expression? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((CAST_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.CAST_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.CAST_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.CAST_EXPRESSION))))

 (define PTREE.UNARY_SIZEOF_TYPE_EXPRESSION
   (lambda (anon:0 anon:1)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.UNARY_SIZEOF_TYPE_EXPRESSION)
     (define UNARY_SIZEOF_TYPE_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self CTOK.key? anon:0)
             (tree-type-check self PTREE.def? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((UNARY_SIZEOF_TYPE_EXPRESSION (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.UNARY_SIZEOF_TYPE_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.UNARY_SIZEOF_TYPE_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.UNARY_SIZEOF_TYPE_EXPRESSION))))

 (define PTREE.ADDITIVE_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.ADDITIVE_EXPRESSION)
     (define ADDITIVE_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((ADDITIVE_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.ADDITIVE_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.ADDITIVE_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.ADDITIVE_EXPRESSION))))

 (define PTREE.MULTIPLICATIVE_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.MULTIPLICATIVE_EXPRESSION)
     (define MULTIPLICATIVE_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self)
        ((MULTIPLICATIVE_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.MULTIPLICATIVE_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.MULTIPLICATIVE_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.MULTIPLICATIVE_EXPRESSION))))

 (define PTREE.SHIFT_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.SHIFT_EXPRESSION)
     (define SHIFT_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((SHIFT_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.SHIFT_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.SHIFT_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.SHIFT_EXPRESSION))))

 (define PTREE.RELATIONAL_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.RELATIONAL_EXPRESSION)
     (define RELATIONAL_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((RELATIONAL_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.RELATIONAL_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.RELATIONAL_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.RELATIONAL_EXPRESSION))))

 (define PTREE.EQUALITY_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.EQUALITY_EXPRESSION)
     (define EQUALITY_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((EQUALITY_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.EQUALITY_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.EQUALITY_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.EQUALITY_EXPRESSION))))

 (define PTREE.AND_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.AND_EXPRESSION)
     (define AND_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((AND_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.AND_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.AND_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.AND_EXPRESSION))))

 (define PTREE.EXCLUSIVE_OR_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.EXCLUSIVE_OR_EXPRESSION)
     (define EXCLUSIVE_OR_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self)
        ((EXCLUSIVE_OR_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.EXCLUSIVE_OR_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.EXCLUSIVE_OR_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.EXCLUSIVE_OR_EXPRESSION))))

 (define PTREE.INCLUSIVE_OR_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.INCLUSIVE_OR_EXPRESSION)
     (define INCLUSIVE_OR_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self)
        ((INCLUSIVE_OR_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.INCLUSIVE_OR_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.INCLUSIVE_OR_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.INCLUSIVE_OR_EXPRESSION))))

 (define PTREE.LOGAND_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.LOGAND_EXPRESSION)
     (define LOGAND_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((LOGAND_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.LOGAND_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.LOGAND_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.LOGAND_EXPRESSION))))

 (define PTREE.LOGOR_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.LOGOR_EXPRESSION)
     (define LOGOR_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((LOGOR_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.LOGOR_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.LOGOR_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.LOGOR_EXPRESSION))))

 (define PTREE.CONDITIONAL_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.CONDITIONAL_EXPRESSION)
     (define CONDITIONAL_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self)
        ((CONDITIONAL_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.CONDITIONAL_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.CONDITIONAL_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.CONDITIONAL_EXPRESSION))))

 (define PTREE.ASSIGNMENT_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.ASSIGNMENT_EXPRESSION)
     (define ASSIGNMENT_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((ASSIGNMENT_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.ASSIGNMENT_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.ASSIGNMENT_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.ASSIGNMENT_EXPRESSION))))

 (define PTREE.COMMA_EXPRESSION
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'expression)
     (define @KONS 'PTREE.COMMA_EXPRESSION)
     (define COMMA_EXPRESSION
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self CTOK.punct? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self) ((COMMA_EXPRESSION (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.COMMA_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.COMMA_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.COMMA_EXPRESSION))))

 (define PTREE.expression?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'expression))))
;;; selectors for polymorphic attributes



;;; initializer
 (define PTREE.NO_INIT
   (lambda ()
     (define @TYPE 'initializer)
     (define @KONS 'PTREE.NO_INIT)
     (define NO_INIT (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((NO_INIT (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.NO_INIT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.NO_INIT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.NO_INIT))))

 (define PTREE.INIT_LIST
   (lambda (anon:0)
     (define @TYPE 'initializer)
     (define @KONS 'PTREE.INIT_LIST)
     (define INIT_LIST
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check-list self PTREE.design_init? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((INIT_LIST (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.INIT_LIST)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.INIT_LIST?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.INIT_LIST))))

 (define PTREE.INIT_EXPR
   (lambda (anon:0)
     (define @TYPE 'initializer)
     (define @KONS 'PTREE.INIT_EXPR)
     (define INIT_EXPR
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check self PTREE.expression? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((INIT_EXPR (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.INIT_EXPR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.INIT_EXPR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.INIT_EXPR))))

 (define PTREE.initializer?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'initializer))))
;;; selectors for polymorphic attributes



;;; design_init -- product type constructed by (cons)
 (define PTREE.design_init?
   (lambda (obj)
     (let ((self (lambda _ 'design_init)))
       (and (is/product/type? obj)
            (apply
             (lambda (anon:0 anon:1)
               (begin
                 (tree-type-check-opt self PTREE.designation? anon:0)
                 (tree-type-check self PTREE.initializer? anon:1)))
             obj)))))

;;; designation
 (define PTREE.DESIGNATION
   (lambda (anon:0)
     (define @TYPE 'designation)
     (define @KONS 'PTREE.DESIGNATION)
     (define DESIGNATION
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check-list self PTREE.desginator? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((DESIGNATION (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DESIGNATION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DESIGNATION?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DESIGNATION))))

 (define PTREE.DESIGNATION_EMPTY
   (lambda ()
     (define @TYPE 'designation)
     (define @KONS 'PTREE.DESIGNATION_EMPTY)
     (define DESIGNATION_EMPTY (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((DESIGNATION_EMPTY (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DESIGNATION_EMPTY)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DESIGNATION_EMPTY?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DESIGNATION_EMPTY))))

 (define PTREE.designation?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'designation))))
;;; selectors for polymorphic attributes



;;; desginator
 (define PTREE.DESIGNATOR_IDX
   (lambda (anon:0)
     (define @TYPE 'desginator)
     (define @KONS 'PTREE.DESIGNATOR_IDX)
     (define DESIGNATOR_IDX
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check self PTREE.expression? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((DESIGNATOR_IDX (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DESIGNATOR_IDX)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DESIGNATOR_IDX?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DESIGNATOR_IDX))))

 (define PTREE.DESIGNATOR_MBR
   (lambda (anon:0)
     (define @TYPE 'desginator)
     (define @KONS 'PTREE.DESIGNATOR_MBR)
     (define DESIGNATOR_MBR
       (lambda (self)
         (lambda (anon:0) (begin (tree-type-check self LEX.id? anon:0)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((DESIGNATOR_MBR (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DESIGNATOR_MBR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DESIGNATOR_MBR?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DESIGNATOR_MBR))))

 (define PTREE.desginator?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'desginator))))
;;; selectors for polymorphic attributes



;;; statement
 (define PTREE.COMPOUND_STAT
   (lambda (anon:0)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.COMPOUND_STAT)
     (define COMPOUND_STAT
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check-list self ROOT.bottom? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((COMPOUND_STAT (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.COMPOUND_STAT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.COMPOUND_STAT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.COMPOUND_STAT))))

 (define PTREE.LABELED_STATEMENT_ID
   (lambda (anon:0 anon:1)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.LABELED_STATEMENT_ID)
     (define LABELED_STATEMENT_ID
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self LEX.id? anon:0)
             (tree-type-check self PTREE.statement? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((LABELED_STATEMENT_ID (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.LABELED_STATEMENT_ID)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.LABELED_STATEMENT_ID?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.LABELED_STATEMENT_ID))))

 (define PTREE.LABELED_STATEMENT_CASE
   (lambda (anon:0 anon:1)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.LABELED_STATEMENT_CASE)
     (define LABELED_STATEMENT_CASE
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.statement? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((LABELED_STATEMENT_CASE (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.LABELED_STATEMENT_CASE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.LABELED_STATEMENT_CASE?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.LABELED_STATEMENT_CASE))))

 (define PTREE.LABELED_STATEMENT_DEFAULT_CASE
   (lambda (anon:0)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.LABELED_STATEMENT_DEFAULT_CASE)
     (define LABELED_STATEMENT_DEFAULT_CASE
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check self PTREE.statement? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((LABELED_STATEMENT_DEFAULT_CASE (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.LABELED_STATEMENT_DEFAULT_CASE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.LABELED_STATEMENT_DEFAULT_CASE?
   (lambda (obj)
     (and (is/sum/type? obj)
          ((obj 'CONSCK) 'PTREE.LABELED_STATEMENT_DEFAULT_CASE))))

 (define PTREE.EXPRESSION_STATEMENT
   (lambda (anon:0)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.EXPRESSION_STATEMENT)
     (define EXPRESSION_STATEMENT
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check self PTREE.expression? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((EXPRESSION_STATEMENT (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.EXPRESSION_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.EXPRESSION_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.EXPRESSION_STATEMENT))))

 (define PTREE.IF_THEN_ELSE_STATEMENT
   (lambda (anon:0 anon:1 anon:2)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.IF_THEN_ELSE_STATEMENT)
     (define IF_THEN_ELSE_STATEMENT
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.statement? anon:1)
             (tree-type-check self PTREE.statement? anon:2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2)))))
     ((lambda (self)
        ((IF_THEN_ELSE_STATEMENT (self self)) anon:0 anon:1 anon:2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.IF_THEN_ELSE_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.IF_THEN_ELSE_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.IF_THEN_ELSE_STATEMENT))))

 (define PTREE.IF_THEN_STATEMENT
   (lambda (anon:0 anon:1)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.IF_THEN_STATEMENT)
     (define IF_THEN_STATEMENT
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.statement? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((IF_THEN_STATEMENT (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.IF_THEN_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.IF_THEN_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.IF_THEN_STATEMENT))))

 (define PTREE.SWITCH_STATEMENT
   (lambda (anon:0 anon:1)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.SWITCH_STATEMENT)
     (define SWITCH_STATEMENT
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.statement? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((SWITCH_STATEMENT (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.SWITCH_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.SWITCH_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.SWITCH_STATEMENT))))

 (define PTREE.FOR_STATEMENT
   (lambda (anon:0 anon:1 anon:2 anon:3)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.FOR_STATEMENT)
     (define FOR_STATEMENT
       (lambda (self)
         (lambda (anon:0 anon:1 anon:2 anon:3)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.expression? anon:1)
             (tree-type-check self PTREE.expression? anon:2)
             (tree-type-check self PTREE.statement? anon:3))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list anon:0 anon:1 anon:2 anon:3)))))
     ((lambda (self) ((FOR_STATEMENT (self self)) anon:0 anon:1 anon:2 anon:3))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.FOR_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.FOR_STATEMENT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.FOR_STATEMENT))))

 (define PTREE.WHILE_STATEMENT
   (lambda (anon:0 anon:1)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.WHILE_STATEMENT)
     (define WHILE_STATEMENT
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.statement? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((WHILE_STATEMENT (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.WHILE_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.WHILE_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.WHILE_STATEMENT))))

 (define PTREE.DO_STATEMENT
   (lambda (anon:0 anon:1)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.DO_STATEMENT)
     (define DO_STATEMENT
       (lambda (self)
         (lambda (anon:0 anon:1)
           (begin
             (tree-type-check self PTREE.expression? anon:0)
             (tree-type-check self PTREE.statement? anon:1))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list anon:0 anon:1)))))
     ((lambda (self) ((DO_STATEMENT (self self)) anon:0 anon:1))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.DO_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.DO_STATEMENT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.DO_STATEMENT))))

 (define PTREE.RETURN_STATEMENT
   (lambda (anon:0)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.RETURN_STATEMENT)
     (define RETURN_STATEMENT
       (lambda (self)
         (lambda (anon:0)
           (begin (tree-type-check self PTREE.expression? anon:0))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((RETURN_STATEMENT (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.RETURN_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.RETURN_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.RETURN_STATEMENT))))

 (define PTREE.BREAK_STATEMENT
   (lambda ()
     (define @TYPE 'statement)
     (define @KONS 'PTREE.BREAK_STATEMENT)
     (define BREAK_STATEMENT (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((BREAK_STATEMENT (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.BREAK_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.BREAK_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.BREAK_STATEMENT))))

 (define PTREE.CONTINUE_STATEMENT
   (lambda ()
     (define @TYPE 'statement)
     (define @KONS 'PTREE.CONTINUE_STATEMENT)
     (define CONTINUE_STATEMENT (lambda (self) (lambda () (begin) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) @KONS))
     ((lambda (self) ((CONTINUE_STATEMENT (self self))))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.CONTINUE_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.CONTINUE_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.CONTINUE_STATEMENT))))

 (define PTREE.GOTO_STATEMENT
   (lambda (anon:0)
     (define @TYPE 'statement)
     (define @KONS 'PTREE.GOTO_STATEMENT)
     (define GOTO_STATEMENT
       (lambda (self)
         (lambda (anon:0) (begin (tree-type-check self LEX.id? anon:0)) self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list anon:0)))))
     ((lambda (self) ((GOTO_STATEMENT (self self)) anon:0))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PTREE.GOTO_STATEMENT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PTREE.GOTO_STATEMENT?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PTREE.GOTO_STATEMENT))))

 (define PTREE.statement?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'statement))))
;;; selectors for polymorphic attributes


