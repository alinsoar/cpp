;; -*- mode:scheme ; buffer-read-only:t -*-

;; TREE PP -- this file was automatically generated by asdlgen

;;; directive
 (define PP.IF
   (lambda (p:pointer
            p:else_branch_pointer
            p:defined_idx
            p:test
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.IF)
     (define IF
       (lambda (self)
         (lambda (p:pointer
                  p:else_branch_pointer
                  p:defined_idx
                  p:test
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:else_branch_pointer)
             (tree-type-check-list self ROOT.integer? p:defined_idx)
             (tree-type-check self ROOT.vector? p:test)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:else_branch_pointer
            p:defined_idx
            p:test
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((IF (self self))
         p:pointer
         p:else_branch_pointer
         p:defined_idx
         p:test
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.IF)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.IF.pointer p:pointer)
            ('PP.IF.else_branch_pointer p:else_branch_pointer)
            ('PP.IF.defined_idx p:defined_idx)
            ('PP.IF.test p:test)
            ('PP.IF.start_line p:start_line)
            ('PP.IF.start_column p:start_column)
            ('PP.IF.end_line p:end_line)
            ('PP.IF.end_column p:end_column)
            ('PP.IF.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.IF.start_line))
            ('PP.directive.start_column ((s s) 'PP.IF.start_column))
            ('PP.directive.end_line ((s s) 'PP.IF.end_line))
            ('PP.directive.end_column ((s s) 'PP.IF.end_column))
            ('PP.directive.filename ((s s) 'PP.IF.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.IF.pointer (lambda (obj) (obj 'PP.IF.pointer)))
 (define PP.IF.else_branch_pointer
   (lambda (obj) (obj 'PP.IF.else_branch_pointer)))
 (define PP.IF.defined_idx (lambda (obj) (obj 'PP.IF.defined_idx)))
 (define PP.IF.test (lambda (obj) (obj 'PP.IF.test)))
 (define PP.IF.start_line (lambda (obj) (obj 'PP.IF.start_line)))
 (define PP.IF.start_column (lambda (obj) (obj 'PP.IF.start_column)))
 (define PP.IF.end_line (lambda (obj) (obj 'PP.IF.end_line)))
 (define PP.IF.end_column (lambda (obj) (obj 'PP.IF.end_column)))
 (define PP.IF.filename (lambda (obj) (obj 'PP.IF.filename)))
 (define PP.IF? (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.IF))))

 (define PP.IFDEF
   (lambda (p:pointer
            p:else_branch_pointer
            p:id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.IFDEF)
     (define IFDEF
       (lambda (self)
         (lambda (p:pointer
                  p:else_branch_pointer
                  p:id
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:else_branch_pointer)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:else_branch_pointer
            p:id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((IFDEF (self self))
         p:pointer
         p:else_branch_pointer
         p:id
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.IFDEF)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.IFDEF.pointer p:pointer)
            ('PP.IFDEF.else_branch_pointer p:else_branch_pointer)
            ('PP.IFDEF.id p:id)
            ('PP.IFDEF.start_line p:start_line)
            ('PP.IFDEF.start_column p:start_column)
            ('PP.IFDEF.end_line p:end_line)
            ('PP.IFDEF.end_column p:end_column)
            ('PP.IFDEF.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.IFDEF.start_line))
            ('PP.directive.start_column ((s s) 'PP.IFDEF.start_column))
            ('PP.directive.end_line ((s s) 'PP.IFDEF.end_line))
            ('PP.directive.end_column ((s s) 'PP.IFDEF.end_column))
            ('PP.directive.filename ((s s) 'PP.IFDEF.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.IFDEF.pointer (lambda (obj) (obj 'PP.IFDEF.pointer)))
 (define PP.IFDEF.else_branch_pointer
   (lambda (obj) (obj 'PP.IFDEF.else_branch_pointer)))
 (define PP.IFDEF.id (lambda (obj) (obj 'PP.IFDEF.id)))
 (define PP.IFDEF.start_line (lambda (obj) (obj 'PP.IFDEF.start_line)))
 (define PP.IFDEF.start_column (lambda (obj) (obj 'PP.IFDEF.start_column)))
 (define PP.IFDEF.end_line (lambda (obj) (obj 'PP.IFDEF.end_line)))
 (define PP.IFDEF.end_column (lambda (obj) (obj 'PP.IFDEF.end_column)))
 (define PP.IFDEF.filename (lambda (obj) (obj 'PP.IFDEF.filename)))
 (define PP.IFDEF?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.IFDEF))))

 (define PP.IFNDEF
   (lambda (p:pointer
            p:else_branch_pointer
            p:id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.IFNDEF)
     (define IFNDEF
       (lambda (self)
         (lambda (p:pointer
                  p:else_branch_pointer
                  p:id
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:else_branch_pointer)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:else_branch_pointer
            p:id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((IFNDEF (self self))
         p:pointer
         p:else_branch_pointer
         p:id
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.IFNDEF)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.IFNDEF.pointer p:pointer)
            ('PP.IFNDEF.else_branch_pointer p:else_branch_pointer)
            ('PP.IFNDEF.id p:id)
            ('PP.IFNDEF.start_line p:start_line)
            ('PP.IFNDEF.start_column p:start_column)
            ('PP.IFNDEF.end_line p:end_line)
            ('PP.IFNDEF.end_column p:end_column)
            ('PP.IFNDEF.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.IFNDEF.start_line))
            ('PP.directive.start_column ((s s) 'PP.IFNDEF.start_column))
            ('PP.directive.end_line ((s s) 'PP.IFNDEF.end_line))
            ('PP.directive.end_column ((s s) 'PP.IFNDEF.end_column))
            ('PP.directive.filename ((s s) 'PP.IFNDEF.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.IFNDEF.pointer (lambda (obj) (obj 'PP.IFNDEF.pointer)))
 (define PP.IFNDEF.else_branch_pointer
   (lambda (obj) (obj 'PP.IFNDEF.else_branch_pointer)))
 (define PP.IFNDEF.id (lambda (obj) (obj 'PP.IFNDEF.id)))
 (define PP.IFNDEF.start_line (lambda (obj) (obj 'PP.IFNDEF.start_line)))
 (define PP.IFNDEF.start_column (lambda (obj) (obj 'PP.IFNDEF.start_column)))
 (define PP.IFNDEF.end_line (lambda (obj) (obj 'PP.IFNDEF.end_line)))
 (define PP.IFNDEF.end_column (lambda (obj) (obj 'PP.IFNDEF.end_column)))
 (define PP.IFNDEF.filename (lambda (obj) (obj 'PP.IFNDEF.filename)))
 (define PP.IFNDEF?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.IFNDEF))))

 (define PP.ELSE
   (lambda (p:pointer
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.ELSE)
     (define ELSE
       (lambda (self)
         (lambda (p:pointer
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((ELSE (self self))
         p:pointer
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.ELSE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.ELSE.pointer p:pointer)
            ('PP.ELSE.start_line p:start_line)
            ('PP.ELSE.start_column p:start_column)
            ('PP.ELSE.end_line p:end_line)
            ('PP.ELSE.end_column p:end_column)
            ('PP.ELSE.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.ELSE.start_line))
            ('PP.directive.start_column ((s s) 'PP.ELSE.start_column))
            ('PP.directive.end_line ((s s) 'PP.ELSE.end_line))
            ('PP.directive.end_column ((s s) 'PP.ELSE.end_column))
            ('PP.directive.filename ((s s) 'PP.ELSE.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.ELSE.pointer (lambda (obj) (obj 'PP.ELSE.pointer)))
 (define PP.ELSE.start_line (lambda (obj) (obj 'PP.ELSE.start_line)))
 (define PP.ELSE.start_column (lambda (obj) (obj 'PP.ELSE.start_column)))
 (define PP.ELSE.end_line (lambda (obj) (obj 'PP.ELSE.end_line)))
 (define PP.ELSE.end_column (lambda (obj) (obj 'PP.ELSE.end_column)))
 (define PP.ELSE.filename (lambda (obj) (obj 'PP.ELSE.filename)))
 (define PP.ELSE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.ELSE))))

 (define PP.ENDIF
   (lambda (p:pointer
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.ENDIF)
     (define ENDIF
       (lambda (self)
         (lambda (p:pointer
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((ENDIF (self self))
         p:pointer
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.ENDIF)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.ENDIF.pointer p:pointer)
            ('PP.ENDIF.start_line p:start_line)
            ('PP.ENDIF.start_column p:start_column)
            ('PP.ENDIF.end_line p:end_line)
            ('PP.ENDIF.end_column p:end_column)
            ('PP.ENDIF.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.ENDIF.start_line))
            ('PP.directive.start_column ((s s) 'PP.ENDIF.start_column))
            ('PP.directive.end_line ((s s) 'PP.ENDIF.end_line))
            ('PP.directive.end_column ((s s) 'PP.ENDIF.end_column))
            ('PP.directive.filename ((s s) 'PP.ENDIF.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.ENDIF.pointer (lambda (obj) (obj 'PP.ENDIF.pointer)))
 (define PP.ENDIF.start_line (lambda (obj) (obj 'PP.ENDIF.start_line)))
 (define PP.ENDIF.start_column (lambda (obj) (obj 'PP.ENDIF.start_column)))
 (define PP.ENDIF.end_line (lambda (obj) (obj 'PP.ENDIF.end_line)))
 (define PP.ENDIF.end_column (lambda (obj) (obj 'PP.ENDIF.end_column)))
 (define PP.ENDIF.filename (lambda (obj) (obj 'PP.ENDIF.filename)))
 (define PP.ENDIF?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.ENDIF))))

 (define PP.JMP
   (lambda (p:pointer_offset
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.JMP)
     (define JMP
       (lambda (self)
         (lambda (p:pointer_offset
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer_offset)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer_offset
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((JMP (self self))
         p:pointer_offset
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.JMP)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.JMP.pointer_offset p:pointer_offset)
            ('PP.JMP.start_line p:start_line)
            ('PP.JMP.start_column p:start_column)
            ('PP.JMP.end_line p:end_line)
            ('PP.JMP.end_column p:end_column)
            ('PP.JMP.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.JMP.start_line))
            ('PP.directive.start_column ((s s) 'PP.JMP.start_column))
            ('PP.directive.end_line ((s s) 'PP.JMP.end_line))
            ('PP.directive.end_column ((s s) 'PP.JMP.end_column))
            ('PP.directive.filename ((s s) 'PP.JMP.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.JMP.pointer_offset (lambda (obj) (obj 'PP.JMP.pointer_offset)))
 (define PP.JMP.start_line (lambda (obj) (obj 'PP.JMP.start_line)))
 (define PP.JMP.start_column (lambda (obj) (obj 'PP.JMP.start_column)))
 (define PP.JMP.end_line (lambda (obj) (obj 'PP.JMP.end_line)))
 (define PP.JMP.end_column (lambda (obj) (obj 'PP.JMP.end_column)))
 (define PP.JMP.filename (lambda (obj) (obj 'PP.JMP.filename)))
 (define PP.JMP?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.JMP))))

 (define PP.MACRO_OBJ
   (lambda (p:pointer
            p:name
            p:replacement_tok_seq
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.MACRO_OBJ)
     (define MACRO_OBJ
       (lambda (self)
         (lambda (p:pointer
                  p:name
                  p:replacement_tok_seq
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.bottom? p:name)
             (tree-type-check-list
              self
              PP.dynamic_lexeme?
              p:replacement_tok_seq)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:name
            p:replacement_tok_seq
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((MACRO_OBJ (self self))
         p:pointer
         p:name
         p:replacement_tok_seq
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.MACRO_OBJ)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.MACRO_OBJ.pointer p:pointer)
            ('PP.MACRO_OBJ.name p:name)
            ('PP.MACRO_OBJ.replacement_tok_seq p:replacement_tok_seq)
            ('PP.MACRO_OBJ.start_line p:start_line)
            ('PP.MACRO_OBJ.start_column p:start_column)
            ('PP.MACRO_OBJ.end_line p:end_line)
            ('PP.MACRO_OBJ.end_column p:end_column)
            ('PP.MACRO_OBJ.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.MACRO_OBJ.start_line))
            ('PP.directive.start_column ((s s) 'PP.MACRO_OBJ.start_column))
            ('PP.directive.end_line ((s s) 'PP.MACRO_OBJ.end_line))
            ('PP.directive.end_column ((s s) 'PP.MACRO_OBJ.end_column))
            ('PP.directive.filename ((s s) 'PP.MACRO_OBJ.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.MACRO_OBJ.pointer (lambda (obj) (obj 'PP.MACRO_OBJ.pointer)))
 (define PP.MACRO_OBJ.name (lambda (obj) (obj 'PP.MACRO_OBJ.name)))
 (define PP.MACRO_OBJ.replacement_tok_seq
   (lambda (obj) (obj 'PP.MACRO_OBJ.replacement_tok_seq)))
 (define PP.MACRO_OBJ.start_line (lambda (obj) (obj 'PP.MACRO_OBJ.start_line)))
 (define PP.MACRO_OBJ.start_column
   (lambda (obj) (obj 'PP.MACRO_OBJ.start_column)))
 (define PP.MACRO_OBJ.end_line (lambda (obj) (obj 'PP.MACRO_OBJ.end_line)))
 (define PP.MACRO_OBJ.end_column (lambda (obj) (obj 'PP.MACRO_OBJ.end_column)))
 (define PP.MACRO_OBJ.filename (lambda (obj) (obj 'PP.MACRO_OBJ.filename)))
 (define PP.MACRO_OBJ?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.MACRO_OBJ))))

 (define PP.MACRO_FUN
   (lambda (p:pointer
            p:name
            p:params
            p:param_count
            p:replacement_tok_seq
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.MACRO_FUN)
     (define MACRO_FUN
       (lambda (self)
         (lambda (p:pointer
                  p:name
                  p:params
                  p:param_count
                  p:replacement_tok_seq
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.bottom? p:name)
             (tree-type-check-list self ROOT.integer? p:params)
             (tree-type-check self ROOT.integer? p:param_count)
             (tree-type-check-list
              self
              PP.dynamic_lexeme?
              p:replacement_tok_seq)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:name
            p:params
            p:param_count
            p:replacement_tok_seq
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((MACRO_FUN (self self))
         p:pointer
         p:name
         p:params
         p:param_count
         p:replacement_tok_seq
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.MACRO_FUN)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.MACRO_FUN.pointer p:pointer)
            ('PP.MACRO_FUN.name p:name)
            ('PP.MACRO_FUN.params p:params)
            ('PP.MACRO_FUN.param_count p:param_count)
            ('PP.MACRO_FUN.replacement_tok_seq p:replacement_tok_seq)
            ('PP.MACRO_FUN.start_line p:start_line)
            ('PP.MACRO_FUN.start_column p:start_column)
            ('PP.MACRO_FUN.end_line p:end_line)
            ('PP.MACRO_FUN.end_column p:end_column)
            ('PP.MACRO_FUN.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.MACRO_FUN.start_line))
            ('PP.directive.start_column ((s s) 'PP.MACRO_FUN.start_column))
            ('PP.directive.end_line ((s s) 'PP.MACRO_FUN.end_line))
            ('PP.directive.end_column ((s s) 'PP.MACRO_FUN.end_column))
            ('PP.directive.filename ((s s) 'PP.MACRO_FUN.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.MACRO_FUN.pointer (lambda (obj) (obj 'PP.MACRO_FUN.pointer)))
 (define PP.MACRO_FUN.name (lambda (obj) (obj 'PP.MACRO_FUN.name)))
 (define PP.MACRO_FUN.params (lambda (obj) (obj 'PP.MACRO_FUN.params)))
 (define PP.MACRO_FUN.param_count
   (lambda (obj) (obj 'PP.MACRO_FUN.param_count)))
 (define PP.MACRO_FUN.replacement_tok_seq
   (lambda (obj) (obj 'PP.MACRO_FUN.replacement_tok_seq)))
 (define PP.MACRO_FUN.start_line (lambda (obj) (obj 'PP.MACRO_FUN.start_line)))
 (define PP.MACRO_FUN.start_column
   (lambda (obj) (obj 'PP.MACRO_FUN.start_column)))
 (define PP.MACRO_FUN.end_line (lambda (obj) (obj 'PP.MACRO_FUN.end_line)))
 (define PP.MACRO_FUN.end_column (lambda (obj) (obj 'PP.MACRO_FUN.end_column)))
 (define PP.MACRO_FUN.filename (lambda (obj) (obj 'PP.MACRO_FUN.filename)))
 (define PP.MACRO_FUN?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.MACRO_FUN))))

 (define PP.UNDEF
   (lambda (p:pointer
            p:id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.UNDEF)
     (define UNDEF
       (lambda (self)
         (lambda (p:pointer
                  p:id
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((UNDEF (self self))
         p:pointer
         p:id
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.UNDEF)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.UNDEF.pointer p:pointer)
            ('PP.UNDEF.id p:id)
            ('PP.UNDEF.start_line p:start_line)
            ('PP.UNDEF.start_column p:start_column)
            ('PP.UNDEF.end_line p:end_line)
            ('PP.UNDEF.end_column p:end_column)
            ('PP.UNDEF.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.UNDEF.start_line))
            ('PP.directive.start_column ((s s) 'PP.UNDEF.start_column))
            ('PP.directive.end_line ((s s) 'PP.UNDEF.end_line))
            ('PP.directive.end_column ((s s) 'PP.UNDEF.end_column))
            ('PP.directive.filename ((s s) 'PP.UNDEF.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.UNDEF.pointer (lambda (obj) (obj 'PP.UNDEF.pointer)))
 (define PP.UNDEF.id (lambda (obj) (obj 'PP.UNDEF.id)))
 (define PP.UNDEF.start_line (lambda (obj) (obj 'PP.UNDEF.start_line)))
 (define PP.UNDEF.start_column (lambda (obj) (obj 'PP.UNDEF.start_column)))
 (define PP.UNDEF.end_line (lambda (obj) (obj 'PP.UNDEF.end_line)))
 (define PP.UNDEF.end_column (lambda (obj) (obj 'PP.UNDEF.end_column)))
 (define PP.UNDEF.filename (lambda (obj) (obj 'PP.UNDEF.filename)))
 (define PP.UNDEF?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.UNDEF))))

 (define PP.INCLUDE_LOCAL
   (lambda (p:pointer
            p:header_id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.INCLUDE_LOCAL)
     (define INCLUDE_LOCAL
       (lambda (self)
         (lambda (p:pointer
                  p:header_id
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:header_id)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:header_id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((INCLUDE_LOCAL (self self))
         p:pointer
         p:header_id
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.INCLUDE_LOCAL)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.INCLUDE_LOCAL.pointer p:pointer)
            ('PP.INCLUDE_LOCAL.header_id p:header_id)
            ('PP.INCLUDE_LOCAL.start_line p:start_line)
            ('PP.INCLUDE_LOCAL.start_column p:start_column)
            ('PP.INCLUDE_LOCAL.end_line p:end_line)
            ('PP.INCLUDE_LOCAL.end_column p:end_column)
            ('PP.INCLUDE_LOCAL.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.INCLUDE_LOCAL.start_line))
            ('PP.directive.start_column ((s s) 'PP.INCLUDE_LOCAL.start_column))
            ('PP.directive.end_line ((s s) 'PP.INCLUDE_LOCAL.end_line))
            ('PP.directive.end_column ((s s) 'PP.INCLUDE_LOCAL.end_column))
            ('PP.directive.filename ((s s) 'PP.INCLUDE_LOCAL.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.INCLUDE_LOCAL.pointer
   (lambda (obj) (obj 'PP.INCLUDE_LOCAL.pointer)))
 (define PP.INCLUDE_LOCAL.header_id
   (lambda (obj) (obj 'PP.INCLUDE_LOCAL.header_id)))
 (define PP.INCLUDE_LOCAL.start_line
   (lambda (obj) (obj 'PP.INCLUDE_LOCAL.start_line)))
 (define PP.INCLUDE_LOCAL.start_column
   (lambda (obj) (obj 'PP.INCLUDE_LOCAL.start_column)))
 (define PP.INCLUDE_LOCAL.end_line
   (lambda (obj) (obj 'PP.INCLUDE_LOCAL.end_line)))
 (define PP.INCLUDE_LOCAL.end_column
   (lambda (obj) (obj 'PP.INCLUDE_LOCAL.end_column)))
 (define PP.INCLUDE_LOCAL.filename
   (lambda (obj) (obj 'PP.INCLUDE_LOCAL.filename)))
 (define PP.INCLUDE_LOCAL?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.INCLUDE_LOCAL))))

 (define PP.INCLUDE_SYSTEM
   (lambda (p:pointer
            p:header_id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.INCLUDE_SYSTEM)
     (define INCLUDE_SYSTEM
       (lambda (self)
         (lambda (p:pointer
                  p:header_id
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.integer? p:header_id)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:header_id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((INCLUDE_SYSTEM (self self))
         p:pointer
         p:header_id
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.INCLUDE_SYSTEM)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.INCLUDE_SYSTEM.pointer p:pointer)
            ('PP.INCLUDE_SYSTEM.header_id p:header_id)
            ('PP.INCLUDE_SYSTEM.start_line p:start_line)
            ('PP.INCLUDE_SYSTEM.start_column p:start_column)
            ('PP.INCLUDE_SYSTEM.end_line p:end_line)
            ('PP.INCLUDE_SYSTEM.end_column p:end_column)
            ('PP.INCLUDE_SYSTEM.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.INCLUDE_SYSTEM.start_line))
            ('PP.directive.start_column ((s s) 'PP.INCLUDE_SYSTEM.start_column))
            ('PP.directive.end_line ((s s) 'PP.INCLUDE_SYSTEM.end_line))
            ('PP.directive.end_column ((s s) 'PP.INCLUDE_SYSTEM.end_column))
            ('PP.directive.filename ((s s) 'PP.INCLUDE_SYSTEM.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.INCLUDE_SYSTEM.pointer
   (lambda (obj) (obj 'PP.INCLUDE_SYSTEM.pointer)))
 (define PP.INCLUDE_SYSTEM.header_id
   (lambda (obj) (obj 'PP.INCLUDE_SYSTEM.header_id)))
 (define PP.INCLUDE_SYSTEM.start_line
   (lambda (obj) (obj 'PP.INCLUDE_SYSTEM.start_line)))
 (define PP.INCLUDE_SYSTEM.start_column
   (lambda (obj) (obj 'PP.INCLUDE_SYSTEM.start_column)))
 (define PP.INCLUDE_SYSTEM.end_line
   (lambda (obj) (obj 'PP.INCLUDE_SYSTEM.end_line)))
 (define PP.INCLUDE_SYSTEM.end_column
   (lambda (obj) (obj 'PP.INCLUDE_SYSTEM.end_column)))
 (define PP.INCLUDE_SYSTEM.filename
   (lambda (obj) (obj 'PP.INCLUDE_SYSTEM.filename)))
 (define PP.INCLUDE_SYSTEM?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.INCLUDE_SYSTEM))))

 (define PP.INCLUDE_EXPRESSION
   (lambda (p:pointer
            p:header_id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.INCLUDE_EXPRESSION)
     (define INCLUDE_EXPRESSION
       (lambda (self)
         (lambda (p:pointer
                  p:header_id
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.bottom? p:header_id)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:header_id
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((INCLUDE_EXPRESSION (self self))
         p:pointer
         p:header_id
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.INCLUDE_EXPRESSION)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.INCLUDE_EXPRESSION.pointer p:pointer)
            ('PP.INCLUDE_EXPRESSION.header_id p:header_id)
            ('PP.INCLUDE_EXPRESSION.start_line p:start_line)
            ('PP.INCLUDE_EXPRESSION.start_column p:start_column)
            ('PP.INCLUDE_EXPRESSION.end_line p:end_line)
            ('PP.INCLUDE_EXPRESSION.end_column p:end_column)
            ('PP.INCLUDE_EXPRESSION.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.INCLUDE_EXPRESSION.start_line))
            ('PP.directive.start_column
             ((s s) 'PP.INCLUDE_EXPRESSION.start_column))
            ('PP.directive.end_line ((s s) 'PP.INCLUDE_EXPRESSION.end_line))
            ('PP.directive.end_column ((s s) 'PP.INCLUDE_EXPRESSION.end_column))
            ('PP.directive.filename ((s s) 'PP.INCLUDE_EXPRESSION.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.INCLUDE_EXPRESSION.pointer
   (lambda (obj) (obj 'PP.INCLUDE_EXPRESSION.pointer)))
 (define PP.INCLUDE_EXPRESSION.header_id
   (lambda (obj) (obj 'PP.INCLUDE_EXPRESSION.header_id)))
 (define PP.INCLUDE_EXPRESSION.start_line
   (lambda (obj) (obj 'PP.INCLUDE_EXPRESSION.start_line)))
 (define PP.INCLUDE_EXPRESSION.start_column
   (lambda (obj) (obj 'PP.INCLUDE_EXPRESSION.start_column)))
 (define PP.INCLUDE_EXPRESSION.end_line
   (lambda (obj) (obj 'PP.INCLUDE_EXPRESSION.end_line)))
 (define PP.INCLUDE_EXPRESSION.end_column
   (lambda (obj) (obj 'PP.INCLUDE_EXPRESSION.end_column)))
 (define PP.INCLUDE_EXPRESSION.filename
   (lambda (obj) (obj 'PP.INCLUDE_EXPRESSION.filename)))
 (define PP.INCLUDE_EXPRESSION?
   (lambda (obj)
     (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.INCLUDE_EXPRESSION))))

 (define PP.ERROR
   (lambda (p:pointer
            p:message
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.ERROR)
     (define ERROR
       (lambda (self)
         (lambda (p:pointer
                  p:message
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.bottom? p:message)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:message
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((ERROR (self self))
         p:pointer
         p:message
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.ERROR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.ERROR.pointer p:pointer)
            ('PP.ERROR.message p:message)
            ('PP.ERROR.start_line p:start_line)
            ('PP.ERROR.start_column p:start_column)
            ('PP.ERROR.end_line p:end_line)
            ('PP.ERROR.end_column p:end_column)
            ('PP.ERROR.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.ERROR.start_line))
            ('PP.directive.start_column ((s s) 'PP.ERROR.start_column))
            ('PP.directive.end_line ((s s) 'PP.ERROR.end_line))
            ('PP.directive.end_column ((s s) 'PP.ERROR.end_column))
            ('PP.directive.filename ((s s) 'PP.ERROR.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.ERROR.pointer (lambda (obj) (obj 'PP.ERROR.pointer)))
 (define PP.ERROR.message (lambda (obj) (obj 'PP.ERROR.message)))
 (define PP.ERROR.start_line (lambda (obj) (obj 'PP.ERROR.start_line)))
 (define PP.ERROR.start_column (lambda (obj) (obj 'PP.ERROR.start_column)))
 (define PP.ERROR.end_line (lambda (obj) (obj 'PP.ERROR.end_line)))
 (define PP.ERROR.end_column (lambda (obj) (obj 'PP.ERROR.end_column)))
 (define PP.ERROR.filename (lambda (obj) (obj 'PP.ERROR.filename)))
 (define PP.ERROR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.ERROR))))

 (define PP.PRAGMA
   (lambda (p:pointer
            p:expr
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)
     (define @TYPE 'directive)
     (define @KONS 'PP.PRAGMA)
     (define PRAGMA
       (lambda (self)
         (lambda (p:pointer
                  p:expr
                  p:start_line
                  p:start_column
                  p:end_line
                  p:end_column
                  p:filename)
           (begin
             (tree-type-check self ROOT.integer? p:pointer)
             (tree-type-check self ROOT.bottom? p:expr)
             (tree-type-check self ROOT.integer? p:start_line)
             (tree-type-check self ROOT.integer? p:start_column)
             (tree-type-check self ROOT.integer? p:end_line)
             (tree-type-check self ROOT.integer? p:end_column)
             (tree-type-check self ROOT.bottom? p:filename))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:pointer
            p:expr
            p:start_line
            p:start_column
            p:end_line
            p:end_column
            p:filename)))))
     ((lambda (self)
        ((PRAGMA (self self))
         p:pointer
         p:expr
         p:start_line
         p:start_column
         p:end_line
         p:end_column
         p:filename))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.PRAGMA)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.PRAGMA.pointer p:pointer)
            ('PP.PRAGMA.expr p:expr)
            ('PP.PRAGMA.start_line p:start_line)
            ('PP.PRAGMA.start_column p:start_column)
            ('PP.PRAGMA.end_line p:end_line)
            ('PP.PRAGMA.end_column p:end_column)
            ('PP.PRAGMA.filename p:filename)
            ('PP.directive.start_line ((s s) 'PP.PRAGMA.start_line))
            ('PP.directive.start_column ((s s) 'PP.PRAGMA.start_column))
            ('PP.directive.end_line ((s s) 'PP.PRAGMA.end_line))
            ('PP.directive.end_column ((s s) 'PP.PRAGMA.end_column))
            ('PP.directive.filename ((s s) 'PP.PRAGMA.filename))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.PRAGMA.pointer (lambda (obj) (obj 'PP.PRAGMA.pointer)))
 (define PP.PRAGMA.expr (lambda (obj) (obj 'PP.PRAGMA.expr)))
 (define PP.PRAGMA.start_line (lambda (obj) (obj 'PP.PRAGMA.start_line)))
 (define PP.PRAGMA.start_column (lambda (obj) (obj 'PP.PRAGMA.start_column)))
 (define PP.PRAGMA.end_line (lambda (obj) (obj 'PP.PRAGMA.end_line)))
 (define PP.PRAGMA.end_column (lambda (obj) (obj 'PP.PRAGMA.end_column)))
 (define PP.PRAGMA.filename (lambda (obj) (obj 'PP.PRAGMA.filename)))
 (define PP.PRAGMA?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.PRAGMA))))

 (define PP.directive?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'directive))))
;;; selectors for polymorphic attributes
 (define PP.directive.start_line
   (lambda (obj)
     (or (PP.directive? obj) (error "poly-attribute" 'directive 'start_line))
     (obj 'PP.directive.start_line)))
 (define PP.directive.start_column
   (lambda (obj)
     (or (PP.directive? obj) (error "poly-attribute" 'directive 'start_column))
     (obj 'PP.directive.start_column)))
 (define PP.directive.end_line
   (lambda (obj)
     (or (PP.directive? obj) (error "poly-attribute" 'directive 'end_line))
     (obj 'PP.directive.end_line)))
 (define PP.directive.end_column
   (lambda (obj)
     (or (PP.directive? obj) (error "poly-attribute" 'directive 'end_column))
     (obj 'PP.directive.end_column)))
 (define PP.directive.filename
   (lambda (obj)
     (or (PP.directive? obj) (error "poly-attribute" 'directive 'filename))
     (obj 'PP.directive.filename)))



;;; static_lexeme
 (define PP.NUMERIC
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.NUMERIC)
     (define NUMERIC
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((NUMERIC (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.NUMERIC)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.NUMERIC.class p:class)
            ('PP.NUMERIC.id p:id)
            ('PP.NUMERIC.co_start_x p:co_start_x)
            ('PP.NUMERIC.co_start_y p:co_start_y)
            ('PP.NUMERIC.co_end_x p:co_end_x)
            ('PP.NUMERIC.co_end_y p:co_end_y)
            ('PP.NUMERIC.splice p:splice)
            ('PP.NUMERIC.filename p:filename)
            ('PP.NUMERIC.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.NUMERIC.class))
            ('PP.static_lexeme.id ((s s) 'PP.NUMERIC.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.NUMERIC.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.NUMERIC.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.NUMERIC.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.NUMERIC.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.NUMERIC.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.NUMERIC.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.NUMERIC.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.NUMERIC.class (lambda (obj) (obj 'PP.NUMERIC.class)))
 (define PP.NUMERIC.id (lambda (obj) (obj 'PP.NUMERIC.id)))
 (define PP.NUMERIC.co_start_x (lambda (obj) (obj 'PP.NUMERIC.co_start_x)))
 (define PP.NUMERIC.co_start_y (lambda (obj) (obj 'PP.NUMERIC.co_start_y)))
 (define PP.NUMERIC.co_end_x (lambda (obj) (obj 'PP.NUMERIC.co_end_x)))
 (define PP.NUMERIC.co_end_y (lambda (obj) (obj 'PP.NUMERIC.co_end_y)))
 (define PP.NUMERIC.splice (lambda (obj) (obj 'PP.NUMERIC.splice)))
 (define PP.NUMERIC.filename (lambda (obj) (obj 'PP.NUMERIC.filename)))
 (define PP.NUMERIC.aux_param (lambda (obj) (obj 'PP.NUMERIC.aux_param)))
 (define PP.NUMERIC?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.NUMERIC))))

 (define PP.FLOAT
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.FLOAT)
     (define FLOAT
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((FLOAT (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.FLOAT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.FLOAT.class p:class)
            ('PP.FLOAT.id p:id)
            ('PP.FLOAT.co_start_x p:co_start_x)
            ('PP.FLOAT.co_start_y p:co_start_y)
            ('PP.FLOAT.co_end_x p:co_end_x)
            ('PP.FLOAT.co_end_y p:co_end_y)
            ('PP.FLOAT.splice p:splice)
            ('PP.FLOAT.filename p:filename)
            ('PP.FLOAT.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.FLOAT.class))
            ('PP.static_lexeme.id ((s s) 'PP.FLOAT.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.FLOAT.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.FLOAT.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.FLOAT.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.FLOAT.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.FLOAT.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.FLOAT.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.FLOAT.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.FLOAT.class (lambda (obj) (obj 'PP.FLOAT.class)))
 (define PP.FLOAT.id (lambda (obj) (obj 'PP.FLOAT.id)))
 (define PP.FLOAT.co_start_x (lambda (obj) (obj 'PP.FLOAT.co_start_x)))
 (define PP.FLOAT.co_start_y (lambda (obj) (obj 'PP.FLOAT.co_start_y)))
 (define PP.FLOAT.co_end_x (lambda (obj) (obj 'PP.FLOAT.co_end_x)))
 (define PP.FLOAT.co_end_y (lambda (obj) (obj 'PP.FLOAT.co_end_y)))
 (define PP.FLOAT.splice (lambda (obj) (obj 'PP.FLOAT.splice)))
 (define PP.FLOAT.filename (lambda (obj) (obj 'PP.FLOAT.filename)))
 (define PP.FLOAT.aux_param (lambda (obj) (obj 'PP.FLOAT.aux_param)))
 (define PP.FLOAT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.FLOAT))))

 (define PP.INTEGER_BIN
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.INTEGER_BIN)
     (define INTEGER_BIN
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((INTEGER_BIN (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.INTEGER_BIN)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.INTEGER_BIN.class p:class)
            ('PP.INTEGER_BIN.id p:id)
            ('PP.INTEGER_BIN.co_start_x p:co_start_x)
            ('PP.INTEGER_BIN.co_start_y p:co_start_y)
            ('PP.INTEGER_BIN.co_end_x p:co_end_x)
            ('PP.INTEGER_BIN.co_end_y p:co_end_y)
            ('PP.INTEGER_BIN.splice p:splice)
            ('PP.INTEGER_BIN.filename p:filename)
            ('PP.INTEGER_BIN.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.INTEGER_BIN.class))
            ('PP.static_lexeme.id ((s s) 'PP.INTEGER_BIN.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.INTEGER_BIN.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.INTEGER_BIN.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.INTEGER_BIN.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.INTEGER_BIN.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.INTEGER_BIN.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.INTEGER_BIN.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.INTEGER_BIN.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.INTEGER_BIN.class (lambda (obj) (obj 'PP.INTEGER_BIN.class)))
 (define PP.INTEGER_BIN.id (lambda (obj) (obj 'PP.INTEGER_BIN.id)))
 (define PP.INTEGER_BIN.co_start_x
   (lambda (obj) (obj 'PP.INTEGER_BIN.co_start_x)))
 (define PP.INTEGER_BIN.co_start_y
   (lambda (obj) (obj 'PP.INTEGER_BIN.co_start_y)))
 (define PP.INTEGER_BIN.co_end_x (lambda (obj) (obj 'PP.INTEGER_BIN.co_end_x)))
 (define PP.INTEGER_BIN.co_end_y (lambda (obj) (obj 'PP.INTEGER_BIN.co_end_y)))
 (define PP.INTEGER_BIN.splice (lambda (obj) (obj 'PP.INTEGER_BIN.splice)))
 (define PP.INTEGER_BIN.filename (lambda (obj) (obj 'PP.INTEGER_BIN.filename)))
 (define PP.INTEGER_BIN.aux_param
   (lambda (obj) (obj 'PP.INTEGER_BIN.aux_param)))
 (define PP.INTEGER_BIN?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.INTEGER_BIN))))

 (define PP.INTEGER_OCT
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.INTEGER_OCT)
     (define INTEGER_OCT
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((INTEGER_OCT (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.INTEGER_OCT)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.INTEGER_OCT.class p:class)
            ('PP.INTEGER_OCT.id p:id)
            ('PP.INTEGER_OCT.co_start_x p:co_start_x)
            ('PP.INTEGER_OCT.co_start_y p:co_start_y)
            ('PP.INTEGER_OCT.co_end_x p:co_end_x)
            ('PP.INTEGER_OCT.co_end_y p:co_end_y)
            ('PP.INTEGER_OCT.splice p:splice)
            ('PP.INTEGER_OCT.filename p:filename)
            ('PP.INTEGER_OCT.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.INTEGER_OCT.class))
            ('PP.static_lexeme.id ((s s) 'PP.INTEGER_OCT.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.INTEGER_OCT.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.INTEGER_OCT.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.INTEGER_OCT.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.INTEGER_OCT.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.INTEGER_OCT.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.INTEGER_OCT.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.INTEGER_OCT.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.INTEGER_OCT.class (lambda (obj) (obj 'PP.INTEGER_OCT.class)))
 (define PP.INTEGER_OCT.id (lambda (obj) (obj 'PP.INTEGER_OCT.id)))
 (define PP.INTEGER_OCT.co_start_x
   (lambda (obj) (obj 'PP.INTEGER_OCT.co_start_x)))
 (define PP.INTEGER_OCT.co_start_y
   (lambda (obj) (obj 'PP.INTEGER_OCT.co_start_y)))
 (define PP.INTEGER_OCT.co_end_x (lambda (obj) (obj 'PP.INTEGER_OCT.co_end_x)))
 (define PP.INTEGER_OCT.co_end_y (lambda (obj) (obj 'PP.INTEGER_OCT.co_end_y)))
 (define PP.INTEGER_OCT.splice (lambda (obj) (obj 'PP.INTEGER_OCT.splice)))
 (define PP.INTEGER_OCT.filename (lambda (obj) (obj 'PP.INTEGER_OCT.filename)))
 (define PP.INTEGER_OCT.aux_param
   (lambda (obj) (obj 'PP.INTEGER_OCT.aux_param)))
 (define PP.INTEGER_OCT?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.INTEGER_OCT))))

 (define PP.INTEGER_DEC
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.INTEGER_DEC)
     (define INTEGER_DEC
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((INTEGER_DEC (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.INTEGER_DEC)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.INTEGER_DEC.class p:class)
            ('PP.INTEGER_DEC.id p:id)
            ('PP.INTEGER_DEC.co_start_x p:co_start_x)
            ('PP.INTEGER_DEC.co_start_y p:co_start_y)
            ('PP.INTEGER_DEC.co_end_x p:co_end_x)
            ('PP.INTEGER_DEC.co_end_y p:co_end_y)
            ('PP.INTEGER_DEC.splice p:splice)
            ('PP.INTEGER_DEC.filename p:filename)
            ('PP.INTEGER_DEC.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.INTEGER_DEC.class))
            ('PP.static_lexeme.id ((s s) 'PP.INTEGER_DEC.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.INTEGER_DEC.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.INTEGER_DEC.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.INTEGER_DEC.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.INTEGER_DEC.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.INTEGER_DEC.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.INTEGER_DEC.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.INTEGER_DEC.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.INTEGER_DEC.class (lambda (obj) (obj 'PP.INTEGER_DEC.class)))
 (define PP.INTEGER_DEC.id (lambda (obj) (obj 'PP.INTEGER_DEC.id)))
 (define PP.INTEGER_DEC.co_start_x
   (lambda (obj) (obj 'PP.INTEGER_DEC.co_start_x)))
 (define PP.INTEGER_DEC.co_start_y
   (lambda (obj) (obj 'PP.INTEGER_DEC.co_start_y)))
 (define PP.INTEGER_DEC.co_end_x (lambda (obj) (obj 'PP.INTEGER_DEC.co_end_x)))
 (define PP.INTEGER_DEC.co_end_y (lambda (obj) (obj 'PP.INTEGER_DEC.co_end_y)))
 (define PP.INTEGER_DEC.splice (lambda (obj) (obj 'PP.INTEGER_DEC.splice)))
 (define PP.INTEGER_DEC.filename (lambda (obj) (obj 'PP.INTEGER_DEC.filename)))
 (define PP.INTEGER_DEC.aux_param
   (lambda (obj) (obj 'PP.INTEGER_DEC.aux_param)))
 (define PP.INTEGER_DEC?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.INTEGER_DEC))))

 (define PP.INTEGER_HEX
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.INTEGER_HEX)
     (define INTEGER_HEX
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((INTEGER_HEX (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.INTEGER_HEX)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.INTEGER_HEX.class p:class)
            ('PP.INTEGER_HEX.id p:id)
            ('PP.INTEGER_HEX.co_start_x p:co_start_x)
            ('PP.INTEGER_HEX.co_start_y p:co_start_y)
            ('PP.INTEGER_HEX.co_end_x p:co_end_x)
            ('PP.INTEGER_HEX.co_end_y p:co_end_y)
            ('PP.INTEGER_HEX.splice p:splice)
            ('PP.INTEGER_HEX.filename p:filename)
            ('PP.INTEGER_HEX.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.INTEGER_HEX.class))
            ('PP.static_lexeme.id ((s s) 'PP.INTEGER_HEX.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.INTEGER_HEX.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.INTEGER_HEX.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.INTEGER_HEX.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.INTEGER_HEX.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.INTEGER_HEX.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.INTEGER_HEX.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.INTEGER_HEX.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.INTEGER_HEX.class (lambda (obj) (obj 'PP.INTEGER_HEX.class)))
 (define PP.INTEGER_HEX.id (lambda (obj) (obj 'PP.INTEGER_HEX.id)))
 (define PP.INTEGER_HEX.co_start_x
   (lambda (obj) (obj 'PP.INTEGER_HEX.co_start_x)))
 (define PP.INTEGER_HEX.co_start_y
   (lambda (obj) (obj 'PP.INTEGER_HEX.co_start_y)))
 (define PP.INTEGER_HEX.co_end_x (lambda (obj) (obj 'PP.INTEGER_HEX.co_end_x)))
 (define PP.INTEGER_HEX.co_end_y (lambda (obj) (obj 'PP.INTEGER_HEX.co_end_y)))
 (define PP.INTEGER_HEX.splice (lambda (obj) (obj 'PP.INTEGER_HEX.splice)))
 (define PP.INTEGER_HEX.filename (lambda (obj) (obj 'PP.INTEGER_HEX.filename)))
 (define PP.INTEGER_HEX.aux_param
   (lambda (obj) (obj 'PP.INTEGER_HEX.aux_param)))
 (define PP.INTEGER_HEX?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.INTEGER_HEX))))

 (define PP.DEFINED
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.DEFINED)
     (define DEFINED
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((DEFINED (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.DEFINED)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.DEFINED.class p:class)
            ('PP.DEFINED.id p:id)
            ('PP.DEFINED.co_start_x p:co_start_x)
            ('PP.DEFINED.co_start_y p:co_start_y)
            ('PP.DEFINED.co_end_x p:co_end_x)
            ('PP.DEFINED.co_end_y p:co_end_y)
            ('PP.DEFINED.splice p:splice)
            ('PP.DEFINED.filename p:filename)
            ('PP.DEFINED.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.DEFINED.class))
            ('PP.static_lexeme.id ((s s) 'PP.DEFINED.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.DEFINED.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.DEFINED.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.DEFINED.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.DEFINED.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.DEFINED.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.DEFINED.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.DEFINED.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.DEFINED.class (lambda (obj) (obj 'PP.DEFINED.class)))
 (define PP.DEFINED.id (lambda (obj) (obj 'PP.DEFINED.id)))
 (define PP.DEFINED.co_start_x (lambda (obj) (obj 'PP.DEFINED.co_start_x)))
 (define PP.DEFINED.co_start_y (lambda (obj) (obj 'PP.DEFINED.co_start_y)))
 (define PP.DEFINED.co_end_x (lambda (obj) (obj 'PP.DEFINED.co_end_x)))
 (define PP.DEFINED.co_end_y (lambda (obj) (obj 'PP.DEFINED.co_end_y)))
 (define PP.DEFINED.splice (lambda (obj) (obj 'PP.DEFINED.splice)))
 (define PP.DEFINED.filename (lambda (obj) (obj 'PP.DEFINED.filename)))
 (define PP.DEFINED.aux_param (lambda (obj) (obj 'PP.DEFINED.aux_param)))
 (define PP.DEFINED?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.DEFINED))))

 (define PP.ID
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.ID)
     (define ID
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((ID (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.ID)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.ID.class p:class)
            ('PP.ID.id p:id)
            ('PP.ID.co_start_x p:co_start_x)
            ('PP.ID.co_start_y p:co_start_y)
            ('PP.ID.co_end_x p:co_end_x)
            ('PP.ID.co_end_y p:co_end_y)
            ('PP.ID.splice p:splice)
            ('PP.ID.filename p:filename)
            ('PP.ID.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.ID.class))
            ('PP.static_lexeme.id ((s s) 'PP.ID.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.ID.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.ID.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.ID.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.ID.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.ID.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.ID.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.ID.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.ID.class (lambda (obj) (obj 'PP.ID.class)))
 (define PP.ID.id (lambda (obj) (obj 'PP.ID.id)))
 (define PP.ID.co_start_x (lambda (obj) (obj 'PP.ID.co_start_x)))
 (define PP.ID.co_start_y (lambda (obj) (obj 'PP.ID.co_start_y)))
 (define PP.ID.co_end_x (lambda (obj) (obj 'PP.ID.co_end_x)))
 (define PP.ID.co_end_y (lambda (obj) (obj 'PP.ID.co_end_y)))
 (define PP.ID.splice (lambda (obj) (obj 'PP.ID.splice)))
 (define PP.ID.filename (lambda (obj) (obj 'PP.ID.filename)))
 (define PP.ID.aux_param (lambda (obj) (obj 'PP.ID.aux_param)))
 (define PP.ID? (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.ID))))

 (define PP.PUNCTUATOR
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.PUNCTUATOR)
     (define PUNCTUATOR
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((PUNCTUATOR (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.PUNCTUATOR)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.PUNCTUATOR.class p:class)
            ('PP.PUNCTUATOR.id p:id)
            ('PP.PUNCTUATOR.co_start_x p:co_start_x)
            ('PP.PUNCTUATOR.co_start_y p:co_start_y)
            ('PP.PUNCTUATOR.co_end_x p:co_end_x)
            ('PP.PUNCTUATOR.co_end_y p:co_end_y)
            ('PP.PUNCTUATOR.splice p:splice)
            ('PP.PUNCTUATOR.filename p:filename)
            ('PP.PUNCTUATOR.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.PUNCTUATOR.class))
            ('PP.static_lexeme.id ((s s) 'PP.PUNCTUATOR.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.PUNCTUATOR.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.PUNCTUATOR.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.PUNCTUATOR.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.PUNCTUATOR.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.PUNCTUATOR.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.PUNCTUATOR.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.PUNCTUATOR.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.PUNCTUATOR.class (lambda (obj) (obj 'PP.PUNCTUATOR.class)))
 (define PP.PUNCTUATOR.id (lambda (obj) (obj 'PP.PUNCTUATOR.id)))
 (define PP.PUNCTUATOR.co_start_x
   (lambda (obj) (obj 'PP.PUNCTUATOR.co_start_x)))
 (define PP.PUNCTUATOR.co_start_y
   (lambda (obj) (obj 'PP.PUNCTUATOR.co_start_y)))
 (define PP.PUNCTUATOR.co_end_x (lambda (obj) (obj 'PP.PUNCTUATOR.co_end_x)))
 (define PP.PUNCTUATOR.co_end_y (lambda (obj) (obj 'PP.PUNCTUATOR.co_end_y)))
 (define PP.PUNCTUATOR.splice (lambda (obj) (obj 'PP.PUNCTUATOR.splice)))
 (define PP.PUNCTUATOR.filename (lambda (obj) (obj 'PP.PUNCTUATOR.filename)))
 (define PP.PUNCTUATOR.aux_param (lambda (obj) (obj 'PP.PUNCTUATOR.aux_param)))
 (define PP.PUNCTUATOR?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.PUNCTUATOR))))

 (define PP.NEWLINE
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.NEWLINE)
     (define NEWLINE
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((NEWLINE (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.NEWLINE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.NEWLINE.class p:class)
            ('PP.NEWLINE.id p:id)
            ('PP.NEWLINE.co_start_x p:co_start_x)
            ('PP.NEWLINE.co_start_y p:co_start_y)
            ('PP.NEWLINE.co_end_x p:co_end_x)
            ('PP.NEWLINE.co_end_y p:co_end_y)
            ('PP.NEWLINE.splice p:splice)
            ('PP.NEWLINE.filename p:filename)
            ('PP.NEWLINE.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.NEWLINE.class))
            ('PP.static_lexeme.id ((s s) 'PP.NEWLINE.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.NEWLINE.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.NEWLINE.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.NEWLINE.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.NEWLINE.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.NEWLINE.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.NEWLINE.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.NEWLINE.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.NEWLINE.class (lambda (obj) (obj 'PP.NEWLINE.class)))
 (define PP.NEWLINE.id (lambda (obj) (obj 'PP.NEWLINE.id)))
 (define PP.NEWLINE.co_start_x (lambda (obj) (obj 'PP.NEWLINE.co_start_x)))
 (define PP.NEWLINE.co_start_y (lambda (obj) (obj 'PP.NEWLINE.co_start_y)))
 (define PP.NEWLINE.co_end_x (lambda (obj) (obj 'PP.NEWLINE.co_end_x)))
 (define PP.NEWLINE.co_end_y (lambda (obj) (obj 'PP.NEWLINE.co_end_y)))
 (define PP.NEWLINE.splice (lambda (obj) (obj 'PP.NEWLINE.splice)))
 (define PP.NEWLINE.filename (lambda (obj) (obj 'PP.NEWLINE.filename)))
 (define PP.NEWLINE.aux_param (lambda (obj) (obj 'PP.NEWLINE.aux_param)))
 (define PP.NEWLINE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.NEWLINE))))

 (define PP.STRING
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.STRING)
     (define STRING
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((STRING (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.STRING)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.STRING.class p:class)
            ('PP.STRING.id p:id)
            ('PP.STRING.co_start_x p:co_start_x)
            ('PP.STRING.co_start_y p:co_start_y)
            ('PP.STRING.co_end_x p:co_end_x)
            ('PP.STRING.co_end_y p:co_end_y)
            ('PP.STRING.splice p:splice)
            ('PP.STRING.filename p:filename)
            ('PP.STRING.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.STRING.class))
            ('PP.static_lexeme.id ((s s) 'PP.STRING.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.STRING.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.STRING.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.STRING.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.STRING.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.STRING.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.STRING.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.STRING.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.STRING.class (lambda (obj) (obj 'PP.STRING.class)))
 (define PP.STRING.id (lambda (obj) (obj 'PP.STRING.id)))
 (define PP.STRING.co_start_x (lambda (obj) (obj 'PP.STRING.co_start_x)))
 (define PP.STRING.co_start_y (lambda (obj) (obj 'PP.STRING.co_start_y)))
 (define PP.STRING.co_end_x (lambda (obj) (obj 'PP.STRING.co_end_x)))
 (define PP.STRING.co_end_y (lambda (obj) (obj 'PP.STRING.co_end_y)))
 (define PP.STRING.splice (lambda (obj) (obj 'PP.STRING.splice)))
 (define PP.STRING.filename (lambda (obj) (obj 'PP.STRING.filename)))
 (define PP.STRING.aux_param (lambda (obj) (obj 'PP.STRING.aux_param)))
 (define PP.STRING?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.STRING))))

 (define PP.CHARACTER
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.CHARACTER)
     (define CHARACTER
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((CHARACTER (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.CHARACTER)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.CHARACTER.class p:class)
            ('PP.CHARACTER.id p:id)
            ('PP.CHARACTER.co_start_x p:co_start_x)
            ('PP.CHARACTER.co_start_y p:co_start_y)
            ('PP.CHARACTER.co_end_x p:co_end_x)
            ('PP.CHARACTER.co_end_y p:co_end_y)
            ('PP.CHARACTER.splice p:splice)
            ('PP.CHARACTER.filename p:filename)
            ('PP.CHARACTER.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.CHARACTER.class))
            ('PP.static_lexeme.id ((s s) 'PP.CHARACTER.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.CHARACTER.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.CHARACTER.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.CHARACTER.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.CHARACTER.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.CHARACTER.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.CHARACTER.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.CHARACTER.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.CHARACTER.class (lambda (obj) (obj 'PP.CHARACTER.class)))
 (define PP.CHARACTER.id (lambda (obj) (obj 'PP.CHARACTER.id)))
 (define PP.CHARACTER.co_start_x (lambda (obj) (obj 'PP.CHARACTER.co_start_x)))
 (define PP.CHARACTER.co_start_y (lambda (obj) (obj 'PP.CHARACTER.co_start_y)))
 (define PP.CHARACTER.co_end_x (lambda (obj) (obj 'PP.CHARACTER.co_end_x)))
 (define PP.CHARACTER.co_end_y (lambda (obj) (obj 'PP.CHARACTER.co_end_y)))
 (define PP.CHARACTER.splice (lambda (obj) (obj 'PP.CHARACTER.splice)))
 (define PP.CHARACTER.filename (lambda (obj) (obj 'PP.CHARACTER.filename)))
 (define PP.CHARACTER.aux_param (lambda (obj) (obj 'PP.CHARACTER.aux_param)))
 (define PP.CHARACTER?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.CHARACTER))))

 (define PP.EOS
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.EOS)
     (define EOS
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((EOS (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.EOS)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.EOS.class p:class)
            ('PP.EOS.id p:id)
            ('PP.EOS.co_start_x p:co_start_x)
            ('PP.EOS.co_start_y p:co_start_y)
            ('PP.EOS.co_end_x p:co_end_x)
            ('PP.EOS.co_end_y p:co_end_y)
            ('PP.EOS.splice p:splice)
            ('PP.EOS.filename p:filename)
            ('PP.EOS.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.EOS.class))
            ('PP.static_lexeme.id ((s s) 'PP.EOS.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.EOS.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.EOS.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.EOS.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.EOS.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.EOS.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.EOS.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.EOS.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.EOS.class (lambda (obj) (obj 'PP.EOS.class)))
 (define PP.EOS.id (lambda (obj) (obj 'PP.EOS.id)))
 (define PP.EOS.co_start_x (lambda (obj) (obj 'PP.EOS.co_start_x)))
 (define PP.EOS.co_start_y (lambda (obj) (obj 'PP.EOS.co_start_y)))
 (define PP.EOS.co_end_x (lambda (obj) (obj 'PP.EOS.co_end_x)))
 (define PP.EOS.co_end_y (lambda (obj) (obj 'PP.EOS.co_end_y)))
 (define PP.EOS.splice (lambda (obj) (obj 'PP.EOS.splice)))
 (define PP.EOS.filename (lambda (obj) (obj 'PP.EOS.filename)))
 (define PP.EOS.aux_param (lambda (obj) (obj 'PP.EOS.aux_param)))
 (define PP.EOS?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.EOS))))

 (define PP.PLACEMAKER_4th
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.PLACEMAKER_4th)
     (define PLACEMAKER_4th
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((PLACEMAKER_4th (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.PLACEMAKER_4th)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.PLACEMAKER_4th.class p:class)
            ('PP.PLACEMAKER_4th.id p:id)
            ('PP.PLACEMAKER_4th.co_start_x p:co_start_x)
            ('PP.PLACEMAKER_4th.co_start_y p:co_start_y)
            ('PP.PLACEMAKER_4th.co_end_x p:co_end_x)
            ('PP.PLACEMAKER_4th.co_end_y p:co_end_y)
            ('PP.PLACEMAKER_4th.splice p:splice)
            ('PP.PLACEMAKER_4th.filename p:filename)
            ('PP.PLACEMAKER_4th.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.PLACEMAKER_4th.class))
            ('PP.static_lexeme.id ((s s) 'PP.PLACEMAKER_4th.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.PLACEMAKER_4th.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.PLACEMAKER_4th.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.PLACEMAKER_4th.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.PLACEMAKER_4th.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.PLACEMAKER_4th.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.PLACEMAKER_4th.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.PLACEMAKER_4th.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.PLACEMAKER_4th.class (lambda (obj) (obj 'PP.PLACEMAKER_4th.class)))
 (define PP.PLACEMAKER_4th.id (lambda (obj) (obj 'PP.PLACEMAKER_4th.id)))
 (define PP.PLACEMAKER_4th.co_start_x
   (lambda (obj) (obj 'PP.PLACEMAKER_4th.co_start_x)))
 (define PP.PLACEMAKER_4th.co_start_y
   (lambda (obj) (obj 'PP.PLACEMAKER_4th.co_start_y)))
 (define PP.PLACEMAKER_4th.co_end_x
   (lambda (obj) (obj 'PP.PLACEMAKER_4th.co_end_x)))
 (define PP.PLACEMAKER_4th.co_end_y
   (lambda (obj) (obj 'PP.PLACEMAKER_4th.co_end_y)))
 (define PP.PLACEMAKER_4th.splice
   (lambda (obj) (obj 'PP.PLACEMAKER_4th.splice)))
 (define PP.PLACEMAKER_4th.filename
   (lambda (obj) (obj 'PP.PLACEMAKER_4th.filename)))
 (define PP.PLACEMAKER_4th.aux_param
   (lambda (obj) (obj 'PP.PLACEMAKER_4th.aux_param)))
 (define PP.PLACEMAKER_4th?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.PLACEMAKER_4th))))

 (define PP.NOLEXEME
   (lambda (p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)
     (define @TYPE 'static_lexeme)
     (define @KONS 'PP.NOLEXEME)
     (define NOLEXEME
       (lambda (self)
         (lambda (p:class
                  p:id
                  p:co_start_x
                  p:co_start_y
                  p:co_end_x
                  p:co_end_y
                  p:splice
                  p:filename
                  p:aux_param)
           (begin
             (tree-type-check self ROOT.symbol? p:class)
             (tree-type-check self ROOT.integer? p:id)
             (tree-type-check self ROOT.integer? p:co_start_x)
             (tree-type-check self ROOT.integer? p:co_start_y)
             (tree-type-check self ROOT.integer? p:co_end_x)
             (tree-type-check self ROOT.integer? p:co_end_y)
             (tree-type-check self ROOT.bottom? p:splice)
             (tree-type-check self ROOT.bottom? p:filename)
             (tree-type-check self ROOT.bottom? p:aux_param))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons
          @KONS
          (map
           tree-repr
           (list
            p:class
            p:id
            p:co_start_x
            p:co_start_y
            p:co_end_x
            p:co_end_y
            p:splice
            p:filename
            p:aux_param)))))
     ((lambda (self)
        ((NOLEXEME (self self))
         p:class
         p:id
         p:co_start_x
         p:co_start_y
         p:co_end_x
         p:co_end_y
         p:splice
         p:filename
         p:aux_param))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.NOLEXEME)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.NOLEXEME.class p:class)
            ('PP.NOLEXEME.id p:id)
            ('PP.NOLEXEME.co_start_x p:co_start_x)
            ('PP.NOLEXEME.co_start_y p:co_start_y)
            ('PP.NOLEXEME.co_end_x p:co_end_x)
            ('PP.NOLEXEME.co_end_y p:co_end_y)
            ('PP.NOLEXEME.splice p:splice)
            ('PP.NOLEXEME.filename p:filename)
            ('PP.NOLEXEME.aux_param p:aux_param)
            ('PP.static_lexeme.class ((s s) 'PP.NOLEXEME.class))
            ('PP.static_lexeme.id ((s s) 'PP.NOLEXEME.id))
            ('PP.static_lexeme.co_start_x ((s s) 'PP.NOLEXEME.co_start_x))
            ('PP.static_lexeme.co_start_y ((s s) 'PP.NOLEXEME.co_start_y))
            ('PP.static_lexeme.co_end_x ((s s) 'PP.NOLEXEME.co_end_x))
            ('PP.static_lexeme.co_end_y ((s s) 'PP.NOLEXEME.co_end_y))
            ('PP.static_lexeme.splice ((s s) 'PP.NOLEXEME.splice))
            ('PP.static_lexeme.filename ((s s) 'PP.NOLEXEME.filename))
            ('PP.static_lexeme.aux_param ((s s) 'PP.NOLEXEME.aux_param))
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.NOLEXEME.class (lambda (obj) (obj 'PP.NOLEXEME.class)))
 (define PP.NOLEXEME.id (lambda (obj) (obj 'PP.NOLEXEME.id)))
 (define PP.NOLEXEME.co_start_x (lambda (obj) (obj 'PP.NOLEXEME.co_start_x)))
 (define PP.NOLEXEME.co_start_y (lambda (obj) (obj 'PP.NOLEXEME.co_start_y)))
 (define PP.NOLEXEME.co_end_x (lambda (obj) (obj 'PP.NOLEXEME.co_end_x)))
 (define PP.NOLEXEME.co_end_y (lambda (obj) (obj 'PP.NOLEXEME.co_end_y)))
 (define PP.NOLEXEME.splice (lambda (obj) (obj 'PP.NOLEXEME.splice)))
 (define PP.NOLEXEME.filename (lambda (obj) (obj 'PP.NOLEXEME.filename)))
 (define PP.NOLEXEME.aux_param (lambda (obj) (obj 'PP.NOLEXEME.aux_param)))
 (define PP.NOLEXEME?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.NOLEXEME))))

 (define PP.static_lexeme?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'static_lexeme))))
;;; selectors for polymorphic attributes
 (define PP.static_lexeme.class
   (lambda (obj)
     (or (PP.static_lexeme? obj) (error "poly-attribute" 'static_lexeme 'class))
     (obj 'PP.static_lexeme.class)))
 (define PP.static_lexeme.id
   (lambda (obj)
     (or (PP.static_lexeme? obj) (error "poly-attribute" 'static_lexeme 'id))
     (obj 'PP.static_lexeme.id)))
 (define PP.static_lexeme.co_start_x
   (lambda (obj)
     (or (PP.static_lexeme? obj)
         (error "poly-attribute" 'static_lexeme 'co_start_x))
     (obj 'PP.static_lexeme.co_start_x)))
 (define PP.static_lexeme.co_start_y
   (lambda (obj)
     (or (PP.static_lexeme? obj)
         (error "poly-attribute" 'static_lexeme 'co_start_y))
     (obj 'PP.static_lexeme.co_start_y)))
 (define PP.static_lexeme.co_end_x
   (lambda (obj)
     (or (PP.static_lexeme? obj)
         (error "poly-attribute" 'static_lexeme 'co_end_x))
     (obj 'PP.static_lexeme.co_end_x)))
 (define PP.static_lexeme.co_end_y
   (lambda (obj)
     (or (PP.static_lexeme? obj)
         (error "poly-attribute" 'static_lexeme 'co_end_y))
     (obj 'PP.static_lexeme.co_end_y)))
 (define PP.static_lexeme.splice
   (lambda (obj)
     (or (PP.static_lexeme? obj)
         (error "poly-attribute" 'static_lexeme 'splice))
     (obj 'PP.static_lexeme.splice)))
 (define PP.static_lexeme.filename
   (lambda (obj)
     (or (PP.static_lexeme? obj)
         (error "poly-attribute" 'static_lexeme 'filename))
     (obj 'PP.static_lexeme.filename)))
 (define PP.static_lexeme.aux_param
   (lambda (obj)
     (or (PP.static_lexeme? obj)
         (error "poly-attribute" 'static_lexeme 'aux_param))
     (obj 'PP.static_lexeme.aux_param)))



;;; dynamic_lexeme
 (define PP.DBG
   (lambda (p:msg)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.DBG)
     (define DBG
       (lambda (self)
         (lambda (p:msg)
           (begin (tree-type-check-list self ROOT.bottom? p:msg))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:msg)))))
     ((lambda (self) ((DBG (self self)) p:msg))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.DBG)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.DBG.msg p:msg)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.DBG.msg (lambda (obj) (obj 'PP.DBG.msg)))
 (define PP.DBG?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.DBG))))

 (define PP.REGS
   (lambda (p:reg_vector)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.REGS)
     (define REGS
       (lambda (self)
         (lambda (p:reg_vector)
           (begin (tree-type-check self ROOT.vector? p:reg_vector))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:reg_vector)))))
     ((lambda (self) ((REGS (self self)) p:reg_vector))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.REGS)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.REGS.reg_vector p:reg_vector)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.REGS.reg_vector (lambda (obj) (obj 'PP.REGS.reg_vector)))
 (define PP.REGS?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.REGS))))

 (define PP.ASSIGN
   (lambda (p:reg p:val)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.ASSIGN)
     (define ASSIGN
       (lambda (self)
         (lambda (p:reg p:val)
           (begin
             (tree-type-check self ROOT.integer? p:reg)
             (tree-type-check self PP.dynamic_lexeme? p:val))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:reg p:val)))))
     ((lambda (self) ((ASSIGN (self self)) p:reg p:val))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.ASSIGN)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.ASSIGN.reg p:reg)
            ('PP.ASSIGN.val p:val)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.ASSIGN.reg (lambda (obj) (obj 'PP.ASSIGN.reg)))
 (define PP.ASSIGN.val (lambda (obj) (obj 'PP.ASSIGN.val)))
 (define PP.ASSIGN?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.ASSIGN))))

 (define PP.ARG
   (lambda (p:idx)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.ARG)
     (define ARG
       (lambda (self)
         (lambda (p:idx)
           (begin (tree-type-check self ROOT.integer? p:idx))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:idx)))))
     ((lambda (self) ((ARG (self self)) p:idx))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.ARG)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.ARG.idx p:idx)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.ARG.idx (lambda (obj) (obj 'PP.ARG.idx)))
 (define PP.ARG?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.ARG))))

 (define PP.TOK
   (lambda (p:tok p:blue_paint p:env)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.TOK)
     (define TOK
       (lambda (self)
         (lambda (p:tok p:blue_paint p:env)
           (begin
             (tree-type-check self PP.static_lexeme? p:tok)
             (tree-type-check self ROOT.box? p:blue_paint)
             (tree-type-check self ROOT.bottom? p:env))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self)
         (cons @KONS (map tree-repr (list p:tok p:blue_paint p:env)))))
     ((lambda (self) ((TOK (self self)) p:tok p:blue_paint p:env))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.TOK)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.TOK.tok p:tok)
            ('PP.TOK.blue_paint p:blue_paint)
            ('PP.TOK.env p:env)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.TOK.tok (lambda (obj) (obj 'PP.TOK.tok)))
 (define PP.TOK.blue_paint (lambda (obj) (obj 'PP.TOK.blue_paint)))
 (define PP.TOK.env (lambda (obj) (obj 'PP.TOK.env)))
 (define PP.TOK?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.TOK))))

 (define PP.EXPAND
   (lambda (p:reg)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.EXPAND)
     (define EXPAND
       (lambda (self)
         (lambda (p:reg)
           (begin (tree-type-check self ROOT.integer? p:reg))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:reg)))))
     ((lambda (self) ((EXPAND (self self)) p:reg))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.EXPAND)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.EXPAND.reg p:reg)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.EXPAND.reg (lambda (obj) (obj 'PP.EXPAND.reg)))
 (define PP.EXPAND?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.EXPAND))))

 (define PP.PASTE
   (lambda (p:reg1 p:reg2)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.PASTE)
     (define PASTE
       (lambda (self)
         (lambda (p:reg1 p:reg2)
           (begin
             (tree-type-check self ROOT.integer? p:reg1)
             (tree-type-check self ROOT.integer? p:reg2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:reg1 p:reg2)))))
     ((lambda (self) ((PASTE (self self)) p:reg1 p:reg2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.PASTE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.PASTE.reg1 p:reg1)
            ('PP.PASTE.reg2 p:reg2)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.PASTE.reg1 (lambda (obj) (obj 'PP.PASTE.reg1)))
 (define PP.PASTE.reg2 (lambda (obj) (obj 'PP.PASTE.reg2)))
 (define PP.PASTE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.PASTE))))

 (define PP.STRINGIZE
   (lambda (p:idx)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.STRINGIZE)
     (define STRINGIZE
       (lambda (self)
         (lambda (p:idx)
           (begin (tree-type-check self ROOT.integer? p:idx))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:idx)))))
     ((lambda (self) ((STRINGIZE (self self)) p:idx))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.STRINGIZE)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.STRINGIZE.idx p:idx)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.STRINGIZE.idx (lambda (obj) (obj 'PP.STRINGIZE.idx)))
 (define PP.STRINGIZE?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.STRINGIZE))))

 (define PP.CONS
   (lambda (p:reg1 p:reg2)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.CONS)
     (define CONS
       (lambda (self)
         (lambda (p:reg1 p:reg2)
           (begin
             (tree-type-check self ROOT.integer? p:reg1)
             (tree-type-check self ROOT.integer? p:reg2))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree
       (lambda (self) (cons @KONS (map tree-repr (list p:reg1 p:reg2)))))
     ((lambda (self) ((CONS (self self)) p:reg1 p:reg2))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.CONS)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.CONS.reg1 p:reg1)
            ('PP.CONS.reg2 p:reg2)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.CONS.reg1 (lambda (obj) (obj 'PP.CONS.reg1)))
 (define PP.CONS.reg2 (lambda (obj) (obj 'PP.CONS.reg2)))
 (define PP.CONS?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.CONS))))

 (define PP.RETURN
   (lambda (p:reg)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.RETURN)
     (define RETURN
       (lambda (self)
         (lambda (p:reg)
           (begin (tree-type-check self ROOT.integer? p:reg))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:reg)))))
     ((lambda (self) ((RETURN (self self)) p:reg))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.RETURN)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.RETURN.reg p:reg)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.RETURN.reg (lambda (obj) (obj 'PP.RETURN.reg)))
 (define PP.RETURN?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.RETURN))))

 (define PP.STATICTOK
   (lambda (p:tok)
     (define @TYPE 'dynamic_lexeme)
     (define @KONS 'PP.STATICTOK)
     (define STATICTOK
       (lambda (self)
         (lambda (p:tok)
           (begin (tree-type-check self PP.static_lexeme? p:tok))
           self)))
     (define $is-a? (lambda (self) (lambda (T) (eq? T @TYPE))))
     (define $kons? (lambda (self) (lambda (x) (eq? x @KONS))))
     (define $tree (lambda (self) (cons @KONS (map tree-repr (list p:tok)))))
     ((lambda (self) ((STATICTOK (self self)) p:tok))
      (lambda (s)
        (lambda (m)
          (case m
            ('CONSID 'PP.STATICTOK)
            ('TYCK ($is-a? (s s)))
            ('TREE ($tree (s s)))
            ('CONSCK ($kons? (s s)))
            ('PP.STATICTOK.tok p:tok)
            (else (error "unknown messagse sent to" @KONS ":" m))))))))
 (define PP.STATICTOK.tok (lambda (obj) (obj 'PP.STATICTOK.tok)))
 (define PP.STATICTOK?
   (lambda (obj) (and (is/sum/type? obj) ((obj 'CONSCK) 'PP.STATICTOK))))

 (define PP.dynamic_lexeme?
   (lambda (obj)
     (and (is/sum/type? obj) (procedure? obj) ((obj 'TYCK) 'dynamic_lexeme))))
;;; selectors for polymorphic attributes


